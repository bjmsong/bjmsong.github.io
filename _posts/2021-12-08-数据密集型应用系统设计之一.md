---
layout:     post
title:      数据密集型应用系统设计
subtitle:   第一部分：数据系统基础
date:       2021-12-08
author:     bjmsong
header-img: img/bigdata.jpeg
catalog: true
tags:
    - 分布式系统
---
分布式系统已经是业界的基础设施，但是会遇到很多问题，这本书都是工业界经验的总结，可以了解到搭一个数据密集型系统，主要要解决的问题有哪些，可以使自己有一个更广的视角来看待目前的工作
前置知识：数据库、计算机系统基础
            
## Chapter1：可靠、可扩展与可维护的应用系统
### 认识数据系统
- 对应于“计算密集型系统”
- “数据”是其成败的决定性因素，包括数据的规模、数据的复杂度以及数据产生与变化的速率等
- 基于标准模块构建,多个组件依靠应用层代码驱动有机衔接起来
    - 数据库: 存储数据
    - 高速缓存: 缓存那些复杂或者操作代价昂贵的结果，以加快下一次访问
    - 索引：用户可以按关键字搜索数据并支持各种过滤
    - 流式处理：持续发送消息至另一个进程，处理采用异步方式
    - 批处理：定期处理大量的累积数据

### 可靠性(Reliability)
- 当出现意外情况如硬件、软件故障、人为失误等，系统应该可以继续正常运转；虽然性能可能有所降低，但确保功能正确
    - 容错/弹性：系统可应对错误
    - 硬件故障
        - 添加硬件冗余：RAID，双电源，热插拔CPU，备用电源，发电机等
        - 软件容错
    - 软件错误
    - 人为失误
        - 以最小出错的方式来设计系统：“做正确的事情”很轻松，但搞坏很复杂
        - 想办法分离最容易出错的地方、容易引发故障的接口。提供一个功能齐全但非生产用的沙箱环境
        - 充分的测试
        - 当出现人为失误时，提供快速的恢复机制以尽量减少故障影响
        - 设置详细而清晰的监控子系统
        - 推行管理流程并加以培训

### 可扩展性(Scalability)
- 随着规模的增值，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长
    - 描述负载
        - 每秒请求处理次数、数据库中写入的比例。。。
    - 描述性能
        - 吞吐量：每秒可处理的记录条数，某制定数据集上运行作业所需的总时间
        - 响应时间：客户端从发送请求到接收响应之间的间隔
            - 常用中位数、百分位表示
            - 服务质量目标：SLO
            - 服务质量协议：SLA
    - 应对负载增加
        - 垂直扩展：升级到更强大的机器
        - 水平扩展：将负载分布到多个更小的机器
        - 弹性：自动检测负载增加，然后自动添加更多计算资源

### 可维护性(Maintainability)
- 随着时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新长江等，系统都应高效运转
    - 可运维性
        - 方便运维团队来保持系统平稳运行
            - 提供对系统运行时行为和内部的可观测性，方便监控
            - 支持自动化，与标准工具集成
            - 避免绑定特定的机器，这样在整个系统不间断运行的同时，允许机器停机维护
            - 提供良好的文档和易于理解的操作模式，诸如“如果我做了X，会发送Y”
            - 提供良好的默认配置，且允许管理员在需要时方便地修改默认值
            - 尝试自我修复，在需要时让管理员手动控制系统状态
            - 行为可预测，减少意外发生
    - 简单性
        - 简化系统复杂性，使新工程师能够轻松理解系统
            - 消除意外复杂性最好的手段之一是抽象
    - 可演化性
        - 后续工程师能够轻松地对系统进行改进，并根据需求变化将其适配到非典型场景
            - 组织流程
                - 敏捷开发

## Chapter2：数据模型与查询语言
### 关系模型与文档模型
- 数据模型
    - 大多数应用程序是通过一层一层叠加数据模型来构建的，每层都通过提供一个简洁的数据模型来隐藏下层的复杂性
    - 这些抽象机制使得不同的人群可以高效协作
- 关系模型
    - SQL
    - 数据被组织成关系（SQL中称为表），其中每个关系是元组（SQL中称为行）的无序集合
    - 较强的联结操作
    - 适合于高度关联的数据
    - 对象-关系不匹配
        - 应用层代码中的对象与表、行和列的数据库模型之间需要一个笨拙的转换层（？）
- 文档模型
    - NoSQL（Not only SQL）
        - 驱动因素
            - 需要比关系型数据库更好的可伸缩性，包括非常大的数据集或非常高的写入吞吐量
            - 相比商业数据库产品，免费和开源软件更受偏爱
            - 关系模型不能很好地支持一些特殊的查询操作
            - 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型
    - JSON
    - 适合于文档结构的数据（即，一对多关系树，通常一次性加载整个树）
    - 模式灵活性
        - 不会强制文档中的数据采用何种模式
        - 读时模式
            - 数据的结构是隐含的，只有在数据被读取时才被解释
            - 写时模式
                - 传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式
            - 读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样
    - 查询的数据局部性
        - 所有相关信息都在同一个地方，一个查询就够了
- 趋势：文档和关系数据库的融合

### 数据查询语言
- 声明式
    - 指定所需数据的模式，结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合），不需要制定如何实现这一目标。
    - 数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分
    - API更简洁容易，对外隐藏了数据库引擎的很多实现细节，这样数据库系统能够在不改变查询语句的情况下提升性能
    - 适合并行执行
    - SQL
- 命令式
    - 告诉计算机以特定顺序执行某些操作
- Mapreduce
    - Google推广的编程模型，用于在多台机器上批量处理大规模的数据
    - 既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间
    - 基于map（也称为collect）和reduce（也称为fold或inject）函数
    - 像SQL这样的更高级的查询语言可以用一系列的MapReduce操作来实现，但是也有很多不使用MapReduce的分布式SQL实现

### 图状数据模型
- 对高度关联的数据而言，文档模型是极其糟糕的，关系模型是可以接受的，而选用图形模型（请参阅“图数据模型”）是最自然的
- 属性图模型
    - 模型
        - 顶点
            - 唯一标识符
            - 一组出边
            - 一组入边
            - 一组属性（键值对）
        - 边
            - 唯一标识符
            - 边的起点/尾部顶点
            - 边的终点/头部顶点
            - 描述两个顶点之间关系类型的标签
            - 一组属性
        - 两个关系表组成：一个存储顶点，另一个存储边
    - 实现
        - Neo4j
            - Cypher
        - Titan
        - InfiniteGraph
- 三元组存储（triple-store）模型
    - 模型
        - 主语，谓语，宾语
            - 主语相当于图中的一个顶点
            - 宾语
                - 原始数据类型中的值
                - 图中的另一个顶点
    - 查询语言
        - SPARQL
    - Datomic，AllegroGraph

## Chapter3：数据存储与检索
### 数据库核心：数据结构
- "日志结构"存储引擎：仅支持追加式更新的数据文件
    - 高效查询
        - 索引：保存一些额外的元数据作为路标，帮助你找到想要的数据
            - 会降低写的速度
        - 哈希索引
            - 索引键-值数据：采用类csv格式来存储key-value对，以内存中的hash map来索引
            - 保存内存中的hash map，把每个键一一映射到数据文件中特定的字节偏移量
            - 如何避免磁盘用尽
                - 将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入一个新的段文件
                - 段压缩（compaction）：在日志中丢弃重复的键，只保留每个键的最近更新
                - 段合并
            - 优化
                - 文件格式
                    - CSV不是日志的最佳格式。使用二进制格式更快，更简单，首先以字节为单位对字符串的长度进行编码，然后使用原始字符串（不需要转义）
                - 删除记录
                    - 如果要删除一个键及其关联的值，则必须在数据文件（有时称为逻辑删除）中附加一个特殊的删除记录。当日志段被合并时，逻辑删除告诉合并过程放弃删除键的任何以前的值
                - 崩溃恢复
                    - 如果数据库重新启动，则内存散列映射将丢失。原则上，可以通过从头到尾读取整个段文件并在每次按键时注意每个键的最近值的偏移量来恢复每个段的哈希映射。但是，如果段文件很大，这可能需要很长时间，这将使服务器重新启动痛苦。 Bitcask通过存储加速恢复磁盘上每个段的哈希映射的快照，可以更快地加载到内存中
            - 缺点
                - key需要全部放在内存中
                - 范围查询效率不高
                例如，无法轻松扫描kitty00000和kitty99999之间的所有键——您必须在散列映射中单独查找每个键
            - 应用
                - Bitcask
        - SSTables(Sorted String Table)
            - 要求
                - 每个键只在每个合并的段文件中出现一次
                - 键值对的顺序按键排序
            - 优点
                - 合并段是简单而高效的，即使文件大于可用内存
                    - 类似于归并排序，并发读取多个输入段文件，比较每个文件的第一个键，把最小的键拷贝到输出文件，重复这个过程
                - 在文件中查找特定的键，不需要保存内存中所有键的索引
                - 读请求往往需要扫描请求范围内的多个key-value对，将这些记录保存到一个块中并在写磁盘之前将其压缩。然后稀疏内存索引的每个条目指向压缩块的开头
            - 如何构建和维护
                - 内存中有许多可以使用的树形数据结构，例如红黑树或AVL树。使用这些数据结构，可以按任何顺序插入键，并按排序顺序读取它们
            - 基本工作流程
                - 写入时，将其添加到内存中的平衡树数据结构（如红黑树），这个内存中的树有时被称为内存表
                - 当内存表大于某个阈值时，将其作为SSTable文件写入磁盘。由于树已经维护了按键排序的key-value对，写磁盘可以比较高效。
                - 处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，接下来是次新的，以此类推
                - 后台进程周期性地执行行段合并与压缩过程，以合并多个段文件，并丢弃那些已经被覆盖或删除的值
            - 应用
                - LevelDB，RocksDB，Cassandra，HBase
                - Lucene是Elasticsearch和Solr使用的一种全文搜索的索引引擎，它使用类似的方法来存储它的词典。全文索引比键值索引复杂得多，但是基于类似的想法
            - LSM存储引擎：基于合并和排序文件原理的存储引擎
- "面向页"的存储引擎
    - **B-tree**
        - 最广泛使用，是几乎所有关系数据库中的标准索引实现，许多非关系型数据库也经常使用
        - 原理
            - 保留按键排序的键值对，可以实现高效的键值查找和范围查询
            - 将数据库分解成固定大小的块或页，传统上大小为4KB，页是内部读写的最小单元。这种设计更接近于底层硬件，因为磁盘也是以固定大小的块排列
            - 每个页面都可以使用地址或位置进行标识，可以让一个页面引用另一个页面，用这些页面引用来构造一个树状页面
            - 某一页被指定为根，每当查找索引中的一个键时，总是从这里开始
            - 分支因子：一个页所包含的子页数量，通常为几百个
            - 确保树保持平衡：具有n个键的B-tree深度为O(logn)
- 对比B-tree和LSM-tree
    - 通常LSM树的写入速度更快，而B树的读取速度更快
    - LSM-tree的优点
        - LSM树通常能够比B树支持更高的写入吞吐量，部分原因是它们有时具有较低的写放大（尽管这取决于存储引擎配置和工作负载），部分是因为它们顺序地写入紧凑的SSTable文件而不是必须覆盖树中的几个页面。这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。
        - LSM树可以被压缩得更好，因此经常比B树在磁盘上产生更小的文件
    - LSM-tree的缺点
        - 压缩过程有时会干扰正在进行的读写操作
        - 如果写入吞吐量很高，并且压缩没有仔细配置，压缩跟不上写入速率。在这种情况下，磁盘上未合并段的数量不断增加，直到磁盘空间用完，读取速度也会减慢，因为它们需要检查更多段文件
- 其它索引结构
    - 二级索引
    - 在索引中存储值
    - 多列索引
    - 全文搜索和模糊索引
- 内存数据库
    - 磁盘的优点
        - 数据保存持久化
        - 成本低
    - 内存实现持久性
        - 电池供电的内存
        - 将更改记录写入磁盘
        - 定期快照写入磁盘
    - 优点
        - 更快
            - 省去了将内存数据结构编码为磁盘数据结构的开销
        - 提供了磁盘索引难以实现的某些数据模型
            - 例如，Redis为各种数据结构（如优先级队列和集合）提供了类似数据库的接口。因为它将所有数据保存在内存中，所以它的实现相对简单。
    - 如果非易失性存储器（NVM） 技术得到更广泛的应用，可能还需要进一步改变存储引擎设计

### 事务处理与分析处理
| 属性 | OLTP(在线事务处理) |  OLAP(在线分析处理) |
| --  | -- | --|
| 主要读特征 | 基于键，每次查询返回少量的记录 | 对大量记录进行汇总 |
| 主要写特征  | 随机访问，低延迟写入用户的输入 | 批量导入 |
| 典型使用场景  | 终端用户，通过网络应用程序 | 内部分析师，为决策提供支持 |
| 数据表征  | 最新的数据状态（当前时间点） | 历史数据 |
| 数据规模  | GB到TB | TB到PB |

- 数据仓库
    - 独立的数据库，分析人员可以查询他们想要的内容而不影响OLTP操作
        - 这些查询的代价很高，要扫描大量数据集，这可能会损害并发执行事务的性能
    - 包含公司各种OLTP系统中所有的只读数据副本
    - 抽取-转换-加载（ETL）
        - 从OLTP数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中
    - 数据仓库可针对分析访问模式进行优化
    - 对比OLTP数据库
        - 数据仓库最常见的是关系型
        - 一个数据仓库和一个关系OLTP数据库看起来很相似，因为它们都有一个SQL查询接口
        - 系统的内部看起来可能完全不同，因为它们针对非常不同的查询模式进行了优化
        - 现在许多数据库供应商都将重点放在支持事务处理或分析工作负载上，而不是两者都支持
    - 分析模式：星型与雪花型
        - 在事务处理领域中使用了大量不同的数据模型。在分析中，数据模型的多样性则少得多。许多数据仓库都以相当公式化的方式使用，被称为星型模式（也称为维度建模）
            - 星型模式
                - 中心：事实表
                    - 每一行代表在特定时间发生的事件
                    - 非常大
                - 维度表
            - 雪花模式
                - 维度进一步细分为子空间
    
### 列式存储
- 应用场景：事实表非常大，典型的数据仓库查询往往一次只会访问其中的几列
- 不要将一行中的所有值存储在一起，而是将每列中的所有值存储在一起
- 适用于关系型、非关系型数据
- 列压缩
    - 每列的值有很多是重复的
    - 位图编码
- 写入会更困难
- 并不是每个数据仓库都必定是一个列存储：传统的面向行的数据库和其他一些架构也被使用。然而，对于专门的分析查询，列式存储可以显著加快，所以它正在迅速普及
- 物化聚合
    - 缓存一些查询使用最频繁的计数或总和
    - 数据立方体或OLAP立方
    - 某些查询变得非常快，因为它们已经被有效地预先计算了

## Chapter4：数据编码与演化
- 数据格式或模式发生变化时，经常需要对应用程序代码进行调整，然而大型应用系统，代码更迭并非易事：
    - 服务端需要滚动升级（分阶段发布）：将新版本先部署到少数几个节点，然后逐步在所有节点上升级新的代码。这样新版本部署无需服务暂停
    - 客户端：寄希望于用户安装更新
- 双向兼容：新旧版本的代码，新旧数据格式，会同时在系统内共存
    - 向后兼容：较新的代码可以读取由旧代码编写的数据
    - 向前兼容：较旧的代码可以读取由新代码编写的数据

### 数据编码格式
- 数据表示形式
    - 内存中
        - 数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）
    - 写入文件，或通过网络发送
        - 必须将其编码（encode）为某种自包含的字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数据结构完全不同。
- 编码(Encoding)/序列化(serialization)：从内存中的表示到字节序列的转化
    - 反之：解码(Decoding)/反序列化(deserialization)
- 语言内置支持将内存中的对象编码为字节序列：通常不是个好主意
    - Java: java.io.Serializable
    - python: pickle
    - 优点：使用方便
    - 缺点
        - 这类编码通常与特定的编程语言深度绑定，其他语言很难读取这种数据
        - 为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源：如果攻击者可以让应用程序解码任意的字节序列，他们就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码
        - 在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题
        - 效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着
- JSON、XML与二进制变体
    - 可由不同编程语言编写和读取
    - JSON，XML和CSV：非常受欢迎
        - 文本格式，可读性强
        - JSON的流行则主要源于Web浏览器的内置支持，以及相对于XML的简单性
        - 缺点
            - 数值（numbers） 的编码多有歧义之处
                - XML和CSV不能区分数字和字符串（除非引用一个外部模式） 
                - JSON虽然区分字符串与数值，但不区分整数和浮点数，而且不能指定精度
            - JSON和XML对Unicode字符串（即人类可读的文本）有很好的支持，但是它们不支持二进制数据（即不带 字符编码(character encoding) 的字节序列）
            - XML和JSON都有可选的模式支持。这些模式语言相当强大，所以学习和实现起来都相当复杂
            - CSV没有任何模式，因此每行和每列的含义完全由应用程序自行定义。如果应用程序变更添加了新的行或列，那么这种变更必须通过手工处理
    - 二进制编码：被很多细分领域所采用
        - 节省空间
        - 支持JSON：MessagePack，BSON，BJSON，UBJSON，BISON和Smile等
        - 支持XML：WBXML和Fast Infoset
- Thrift、Protocol Buffers
    - 序列化和反序列化
    https://www.youtube.com/watch?v=6-N34-pNMNs&list=PLLuMmzMTgVK7XfFadhkPuF_ztvhxbriDr&index=6&ab_channel=HuaHua
        - why need serialization
            - we can't just store the memory addresses of objects since there is no way to restore it 
            - serialization is the process of translating data structutres or object state into a format that can be stored or transmitted and reconstructed later
        - how to serilize
            - text: human readable string/bytes array
                - XML
                - Json
                - QueryString
            - bytes: binary format
        - ProtoBuf
            - https://developers.google.com/protocol-buffers/docs/cpptutorial?hl=zh-cn
            - language-neutral,platform-neural,extensible(向下兼容)
            - 步骤
                ■ 定义.proto文件：描述数据结构
                ■ 编译protocol buffer：>protoc
                ■ 生成语言(C++/Java//Python)对应的类库，提供了操作对象的API
            - 如何使用
            https://www.bilibili.com/video/BV1av41137cp?p=7&vd_source=7798c62f92ce545f56fd00d4daf55e26
            - binary format
                - Type
                - Tag
                - Varints
    - 基于相同原理的二进制编码库
    - 需要模式来编码任何数据
        - 模式语言比JSON、XML模式简单得多，支持更详细的验证规则
    - 带有代码生成工具，生成支持多种编程语言的类
    - Thrift：Facebook
    - Protocol Buffers：Google
    https://github.com/protocolbuffers/protobuf
    https://zhuanlan.zhihu.com/p/425528252
    https://www.bilibili.com/video/BV1Mq4y1Q7Yh/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7798c62f92ce545f56fd00d4daf55e26
    https://blog.csdn.net/u014630623/article/details/88992609
    https://blog.conan.io/2019/03/06/Serializing-your-data-with-Protobuf.html
    https://halfrost.com/protobuf_encode/
    - 很好地应对模式演化（模式不可避免地需要随着时间而不断变化）
- Avro
    - Hadoop的子项目

### 数据流模式
- 基于数据库的数据流
    - 写入数据库的进程对数据进行编码，读取数据库的进程对数据进行解码
    - 需要向后兼容、向前兼容
- 基于服务的数据流：REST和RPC
    - 服务：服务器公开的API
        - 客户端可以连接到服务器以向该API发出请求
    - web服务
        - 客户端（Web浏览器、移动设备、桌面计算机上运行的本地应用程序）向Web服务器发出请求
            - GET请求：下载HTML、CSS、JavaScript、图像等
            - POST请求：提交数据到服务器
        - API包含一组标准的协议和数据格式：HTTP、URL、SSL/TLS、HTML等
        - 方法
            - REST
                - 不是一个协议，而是一个基于HTTP原则的设计理念
                - 强调简单的数据格式，使用URL来标识资源，并使用HTTP功能进行缓存控制、身份验证和内容类型协商
                - RESTful：根据REST原则所设计的API
            - SOAP
                - 基于XML的协议，用于发出网络API的请求
    - 微服务体系结构/面向服务的体系结构(SOA)
        - 将大型应用程序按照功能区域分解为较小的服务，这样当一个服务需要另一个服务的某些功能或数据时，就会向另一个服务发出请求
        - 关键设计目标：通过使服务可独立部署和演化，让应用程序更易于更改和维护
    - 远程过程调用(RPC)
        - 使向远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同

- 基于消息传递的数据流
    - RPC和数据库之间的异步消息传递系统
        - 与RPC类似，因为客户端的请求（通常称为消息）以低延迟传送到另一个进程
        - 与数据库类似，不是通过直接的网络连接发送消息，而是通过称为消息代理（也称为消息队列或面向消息的中间件）的中介来临时存储消息。
    - 与直接RPC相比，使用消息代理有几个优点
        - 如果收件人不可用或过载，可以充当缓冲区，从而提高系统的可靠性
        - 它可以自动将消息重新发送到已经崩溃的进程，从而防止消息丢失
        - 避免发件人需要知道收件人的IP地址和端口号（这在虚拟机经常出入的云部署中特别有用）
        - 它允许将一条消息发送给多个收件人
        - 将发件人与收件人逻辑分离（发件人只是发布邮件，不关心使用者）
    - 开源框架
        - RabbitMQ，Apache Kafka




