---
layout:     post
title:      设计模式之美
subtitle:   
date:       2022-08-24
author:     bjmsong
header-img: 
catalog: true
tags:
    - 设计模式
---
## 导读
- 学习设计模式的意义
    - 应对面试
    - 提高代码质量
    - 提高复杂代码的设计和开发能力
    - 更好地读源码、学框架
    - 为职场发展做铺垫
- 评价标准
    - 可维护性：在不破坏原有设计、不引入新的bug情况下，能够快速地修改或添加代码
    - 可读性
    - 可扩展性：在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码
    - 灵活性
    - 简洁性
    - 可复用性
    - 可测试性
- 面向对象，设计原则，设计模式，编码规范，代码重构
    - 面向对象编程因为其具有丰富的特性(封装、抽象、多态、继承)，可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础
    - 设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义
    - 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。设计模式比设计原则更具体，更可执行。
    - 编程规范主要解决代码的可读性问题
    - 重构是保证代码质量不下降的手段，利用的就是面向对象，设计原则，设计模式，编码规范这些理论


## 面向对象
- 定义：以类和对象作为组织代码的基本单元，将封装、继承、多态、抽象作为代码设计和实现的基石
- 四大特性
    - 封装
        - 信息隐匿，数据访问保护
        - 提高代码的可控性，增加类的易用性
    - 抽象
        - 隐藏方法的具体实现，调用者只需要了解提供了哪些功能，不需要知道这些功能是怎么实现的
        - 基于接口类或者抽象类来实现
        - 类、函数等本身就是一种抽象
    - 继承
        - 意义：代码复用
        - 过度使用继承，继承层次过深过复杂，代码可读性会变差
    - 多态
        - 子类可以代替父类，调用子类的方法来实现
        - 提高代码的复用性和可扩展性
- UML：学习、沟通成本高，用处并不大
- 面向对象 vs 面向过程
    - 面向过程：以过程（函数、方法、操作）作为组织代码的基本单元，以数据（成员变量、属性）与方法相分离为最主要的特点
- 接口&抽象类
    - 抽象类
        - 不允许被实例化，只能被继承
        - 可以包含属性和方法，方法可以包含代码实现，也可以不包含代码实现（抽象方法）
        - 子类继承抽象类，必须实现抽象类中的所有方法
        - 表示is-a关系
        - 意义：代码复用，实现多态
    - 接口
        - 不能包含属性
        - 只能声明方法，方法不能包含代码实现
        - 类实现接口的时候，必须实现接口中声明的所有方法
        - 表示has-a关系，表示具有某些功能，也叫协议(contract)
        - 意义：解耦
    - 可以用抽象类来模拟接口
- 基于接口而非实现编程
    - 接口：一组“协议”或者“约定”，是提供给使用者的一个“功能列表”。可以理解为编程语言中的接口或抽象类
    - 上游系统面向接口而非实现编程，不依赖不稳定的实现细节。当实现发送变化的时候，上游系统的代码基本不需要改动，以此来降低耦合性，提高扩展性
    - 如何做到
        - 函数的命名不能暴露任何实现细节
        - 封装具体的实现细节
        - 为实现类定义抽象的接口
- 多用组合少用继承
    - 继承的缺点：实际情况复杂，类的继承层次越来越深，继承关系越来越复杂。会导致代码的可读性变差，也破坏了类的封装特性，将父类的实现细节暴露给了子类。
    - 组合（表示is-a关系）+接口（支持多态）+委托（代码复用）
    - 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅，继承关系不复杂，就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，尽量使用组合代替继承。
- 基于贫血模型的MVC架构 
    - 面向过程：数据与操作分离
    - M(Model),V(View),C(Controller)
    - 展示层(接口)，逻辑层(具体业务逻辑)，数据层(数据库交互)
- 基于DDD充血模式的MVC架构
    - 面向对象
- 实战：接口鉴权
    - 面向对象分析：产出详细的需求描述
    - 面向对象设计：产出类
        - 划分职责进而识别出有哪些类
            - 方法一：把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选
            - 方法二(推荐)：根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类
        - 定义类及其属性和方法
            - 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。
        - 定义类与类之间的交互关系
            - 泛化：继承
            - 实现：接口和实现类
            - 关联：是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面， 如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系
            - 聚合：包含关系，A类对象包含B类对象，B类对象的生命周期可 以不依赖A类对象的生命周期
            - 组合：包含关系。A类对象包含B类对象，B类对象的生命周期 跟依赖A类对象的生命周期，B 类对象不可单独存在
            - 依赖：是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象 是 A 类对象的成员变量，还是 A 类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，我们都称它们有依赖关系
        - 将类组装起来并提供执行入口
    - 面向对象编程


## 设计原则
- SOLID原则
    - 单一职责(SRP): 一个类或者模块只负责完成一个职责(或者功能)
    - 开闭原则(OCP): 对扩展开放、对修改关闭
        - 最难理解、最难掌握，同时也是最有用的一条原则
        - 扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则
        - 添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法等)，而非修改已有代码(修改模块、类、方法等)
    - 里式替换原则(LSP)
        - 子类对象(object of subtype/derived class)能够替换程序(program)中父类对象(object of base/parent class)出现的任何地方，并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏
        - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破 坏原有程序的正确性
        - 子类在设计的时候，要遵守父类的行为约定(或者叫协议)。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括:函数声明要实现的功能;对输入、输出、异常 的约定;甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系
    - 接口隔离原则(ISP)
        - 客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者
        - 接口
            - 一组API接口集合
            - 单个API接口或函数：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
            - OOP中的接口概念
    - 依赖反转原则(DIP)
        - 依赖注入：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(或注入)给类使用
- DRY原则
- KISS原则
- YAGNI原则
- LOD法则


### 规范与重构
- 定义：在保持功能不变的前提下，利用设计思想、原则、模式、编码规范等理论来优化代码，修改设计上的不足，提高代码质量
- 目的、对象、时机、方法
- 单元测试(Unit Testing): 最可落地执行、最有效的保证重构不出错的手段
    - 单元测试相对于集成测试(Integration Testing)来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端(end to end)的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。是代码层级的测试。
    - 单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一(另一个是Code Review)
- 大重构:大规模高层次
    - 解耦：实现代码高内聚，低耦合
        - 封装与抽象
        - 中间层
        - 模块化
- 小重构:小规模低层次
    - 20条最快速改善代码质量的编程规范
        - 命名与注释(Naming and Comments)
            - 命名的关键是能准确达意
            - 注释的目的就是让代码更容易看懂
        - 代码风格(Code Style)
        - 编程技巧(Coding Tips)
            - 把代码分割成更小的单元块
            - 避免函数参数过多
                - 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数
                - 将函数的参数封装成对象
            - 勿用函数参数来控制逻辑
            - 函数设计要职责单一
            - 移除过深的嵌套层次
            - 学会使用解释性变量
                - 使用解释性变量来解释复杂表达式
- 如何发现代码质量问题：checklist
    - 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”?
    - 是否遵循经典的设计原则和设计思想(SOLID、DRY、KISS、YAGNI、LOD 等)?
    - 设计模式是否应用得当?是否有过度设计?
    - 代码是否容易扩展?如果要添加新功能，是否容易实现?
    - 代码是否可以复用?是否可以复用已有的项目代码或类库?是否有重复造轮子?
    - 代码是否容易测试?单元测试是否全面覆盖了各种正常和异常的情况?
    - 代码是否易读?是否符合编码规范(比如命名和注释是否恰当、代码风格是否一致？
- 设计函数在异常情况下的返回数据类型
    - 返回错误码
        - C语言没有异常这样的语法机制，返回错误码便是最常用的出错处理方式。而 Java、 Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码
        - C++也常用这种方式
        - 如果编程语言中有异常这种语法机制，那就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息(exception 中可以有 message、stack trace 等信息)等
    - 返回NULL值
        - 在多数编程语言中，我们用NULL来表示“不存在”这种语义。对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示不存在语义的 NULL 值比返回 异常更加合理。
    - 返回空对象
        - 返回NULL值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。
    - 抛出异常对象
        - 最常用的函数出错处理方式是抛出异常。
        - C++ 和大部分的动态语言(Python、Ruby、 JavaScript 等)都只定义了一种异常类型:运行时异常(Runtime Exception，非受检异常)。而像 Java，除了运行时异常外，还定义了另外一种异常类型:编译时异常(Compile Exception，受检异常)。
        - 对于应该用受检异常还是非受检异常，网上的争论有很多，但也并没有一个非常强有力的理由，说明一个就一定比另一个更好。所以，我们只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。
        - 对于函数抛出的异常，有三种处理方法
            - 直接吞掉：如果抛出的异常是可以恢复，且调用方并不关心此异常
            - 直接往上抛出：如果抛出的异常对调用方来说，也是可以理解的、关心的，并且在业务概念上有一定的相关性
            - 包裹成新的异常抛出：如果抛出的异常太底层，对调用方来说，缺乏背景去理解、且业务概念上无关


## 设计模式：创建型
### 单例模式
https://zhuanlan.zhihu.com/p/37469260
- 一个类只允许创建一个对象(或者叫实例)
- 为什么要使用单列
    - 从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类
    - 解决资源访问冲突的问题
        - 单例模式相对于之前类级别锁的好处是，不用创建那么多Logger对象，一方面节省内存空间，另一方面节省系统文件句 柄(对于操作系统来说，文件句柄也是一种资源，不能随便浪费)
- 实现方式
    - 饿汉式
        - 在类加载的期间，就已经将 instance静态实例初始化好了，所以，instance实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
    - 懒汉式
        - 支持延迟加载
        - 并发度很低
    - 双重检测
        - 既支持延迟加载、又支持高并发
    - 静态内部类
    - 枚举
        - 最简单的实现方式
- 单例模式有哪些问题
    - 单例这种设计模式对于OOP中的抽象、继承、多态都支持得不好
    - 单例会隐藏类之间的依赖关系
    - 单例对代码的扩展性不友好
    - 单例对代码的可测试性不友好
    - 单例不支持有参数的构造函数
- 替代解决方案
    - 寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强 制保证，也可以通过工厂模式、IOC 容器(比如 Spring IOC 容器)来保证，还可以通过程 序员自己来保证(自己在编写代码的时候自己保证不要创建两个类对象)

### 工厂模式
- 当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创 建过程，将对象的创建和使用相分离。
- 简单工厂
- 工厂方法
- 抽象工厂
- 模板工厂
https://zhuanlan.zhihu.com/p/83535678
https://zhuanlan.zhihu.com/p/83537599

### 建造者模式


## 设计模式：结构型
- 代理模式
- 桥接模式
- 装饰者模式
- 适配器模式


## 设计模式：行为型
- 观察者模式
- 模板模式
- 策略模式
- 职责链模式
- 迭代器模式
- 状态模式


## 开源实战


## 项目实战
- 
- 
- 

## 参考资料
- 极客时间 《设计模式之美》
