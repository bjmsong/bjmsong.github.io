---
layout:     post
title:      算法与数据结构之三
subtitle:   查找
date:       2019-11-25
author:     bjmsong
header-img: img/Algo/algo.jpg
catalog: true
tags:
    - 算法
---
>本文将介绍


## 查找
3.1 符号表（字典，索引）
- 将一个键和一个值联系起来
- 高效地插入和查找
- 键不允许重复
- 有序符号表：键有序
- 测试用例
    - 行为测试
    - 性能测试
- 实现
    - 链表
        - 每个结点存储一个键值对
        - 查询慢，插入慢
    - 有序数组
        - 一对平行的数组
        - 键有序
        - 查询快，插入慢
    - 二叉查找树
    - 平衡查找树
    - 散列表

3.2 二叉查找树
- **结合链表插入的灵活性和有序数组查找的高效性**
- 二叉查找树
    - 每个结点都只有左右两个链接（可以为空）
    - **每个结点的键都大于其左子树中的任意结点的键，小于右子树的任意结点的键**
- 私有类表示二叉树的一个结点（跟链表类似）
    - 一个键
    - 一个值
    - 一条左链接
    - 一条右链接
    - 一个结点计数器（以该结点为根节点的子树的结点总数）
- 性能
    - 树的高度决定了所有操作在最坏情况下的性能
    - 平均情况下: O(1.39lgN)
    - 最坏情况下：O(N) 
        - 键有序插入，非随机
- 反转二叉树？

3.3 平衡查找树
- 2-3查找树
    - 2-结点
        - 一个键
        - 两条链接
    - 3-结点
        - 两个键
        - 三条链接
            - 中链接的键位于两个键之间
    - 完美的2-3查找树的所有空链接到根节点的距离都是相同的
    - 操作不方便
- 红黑二叉查找树
    - 用标准的二叉查找树和一些额外的信息来表示2-3树
    - 红链接：将两个2-结点连接起来构成一个3-结点
    - 黑链接：2-3树中的普通链接
    - 对于任意2-3树，只要对结点进行转换，就可以派生出一棵对应的二叉查找树
- 性能
    - 插入和查询：对数时间

3.4 散列表(哈希表)
- 实现无序的符号表
  
    - python字典的底层实现方式
- 时间和空间上的权衡
- 散列的查找算法
    - step1：用散列函数将被查找的键转化为数组的一个索引
        - 多个键可能回散列到相同的索引值
    - step2：处理碰撞冲突
        - 拉链法
        - 线性探测法
- 散列函数
    - 易于计算并且能够均匀分布所有的键
    - 和键的类型有关：对于每种类型的键都需要一个与之对应的散列函数
- 拉链法
  
    - 数组的每个元素指向一条链表
- 线性探测法
    - 数组长度大于键值对数量
    - 依靠数组中的空位解决碰撞冲突
- 性能
  
- 查找，插入：常数时间
  
- 哈希算法
    - 定义
    又称散列算法，是将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。它的原理其实很简单，就是把一段交易信息转换成一个固定长度的字符串。

    - 特点
    1. 信息相同，字符串也相同
    2. 信息相似不会影响字符串相同
    3. 可以生成无数的信息，但是字符串的种类是一定的，所以是不可逆的

    - 用途
    1. 文件校验
    2. 数字签名

    - hash算法
    1. MD5
    2. SHA
    

3.5 应用
- 散列表 vs 红黑树
    - 散列表代码简单，查找时间最优
    - 红黑树不需要设计散列函数，保证最坏情况下的性能，支持的操作更多
- 集合
- 字典类
- 索引类
    - 一个键与多个值关联的符号表
    - 反向索引
        - 值来查找键
- 稀疏向量


## 参考资料
- Algorithms，Robert Sedgewick
- 
