---
layout:     post
title:      Algorithms之二
subtitle:   排序算法
date:       2019-12-05
author:     bjmsong
header-img: img/Algo/algorithms.jpg
catalog: true
tags:
    - 算法
---
>本文将介绍排序算法，包括插入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时还会介绍另外一些算法，用于解决跟排序相关的问题，包括优先队列、选举以及归并。



### 排序算法总结

| 最坏情况 | 是否稳定 | 是否为原地排序 | 时间复杂度 | 空间复杂度 | 适用场景 |
| -------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| 选择排序 |     否     |     是     |      N^2     |     1       |            |
| 插入排序 |      是      |      是      |      介于N和N^2之间      |         1     |     **序列部分有序**         |
| 冒泡排序 |      是   |      是   |       N^2   |       1     |            |
| 希尔排序 | 否 | 是 | ？ | 1 |  |
| 归并排序   | 是 | 否 | NlogN | N |  |
| **快速排序**         | 否 | 是 | NlogN | logN | **非常脆弱，在实现时要非常小心才能避免低劣的性能** |
| 堆排序         | 否 | 是 | NlogN | 1 | 应用很少，因为它无法利用缓存 |
| 桶排序         | 否 | 否 | **N** | N | 序列中的最大值比较小 |

- 稳定性：保留数组中重复元素的相对位置
- 稳定性的好处：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用
- 各排序算法的稳定性：
    - 堆排序、快速排序、希尔排序、直接选择排序**不是稳定**的排序算法；
    - 基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是**稳定**的排序算法。
- https://cloud.tencent.com/developer/article/1182321

### 初级排序算法

- 选择排序
    - 遍历数组，找到最小的元素，和数组的第一个元素交换顺序
    - 运行时间和输入无关
    - 数据移动是最少的，交换次数和数组的大小是线性关系
- 冒泡排序
    - 依次比较相邻元素，把最大的元素逐步移动到末尾
    - 和选择排序类似，每一轮都是把最大/最小的元素找出来，只是找的方式有些区别
- 插入排序
    - 遍历数组，依次跟左边的元素比较，保证左边始终有序 
    - 就像**理牌**一样
    - 运行时间取决于输入元素中的初始顺序
        - 对部分有序的数组比较高效
        - 最坏情况：N^2/2次比较，N^2/2次交换
        - 最好情况：N-1次比较，0次交换
- 希尔排序
    - 基于插入排序
    - h有序：使数组中任意间隔为h的元素都是有序的
    - h从N/3开始递减到1
    - 比插入排序和选择排序快得多，且不需要额外空间，代码量很小



### 归并排序
- 先递归地将数组分成两半，分别排序，然后将结果归并起来

- 自顶向下归并
  
    - 分治思想(divide and conquer)
    
- 自底向上的归并
    - 外层循环：子数组大小(1,2,4,..)
    - 内层循环：子数组索引
    
- 缺点：额外空间和N成正比

    - 原地归并：实现非常复杂

- python有一个模块，专门提供了归并排序的方法，叫做“heapq”模块

    ```python
    from heapq import merge
    
    def merge_sort(lst):
        if len(lst) <= 1:
            return lst          # 从递归中返回长度为1的序列
        middle = len(lst) // 2
        left = merge_sort(lst[:middle])     # 通过不断递归，将原始序列拆分成n个小序列
        right = merge_sort(lst[middle:])
        return list(merge(left, right))
    
    
    merge_sort([11, 99, 33 , 69, 77, 88, 55, 11, 33, 36,39, 66, 44, 22])
    
    # 返回结果[11, 11, 22, 33, 33, 36, 39, 44, 55, 66, 69, 77, 88, 99]
    ```


### 快速排序(quick sort)：最快的通用排序算法
- 由C. A. R. Hoare在1962年提出，被誉为二十世纪科学和工程领域的十大算法之一
- 采用了分治的策略, 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
- 快排的原理可以看下以下两个视频
    - [罗马尼亚舞团舞蹈](https://www.bilibili.com/video/av16290537?from=search&seid=10248348647103581642)
    - [TED-ed](https://www.bilibili.com/video/av10076626/?spm_id_from=333.788.videocard.18)
- 算法步骤
    - 在数列之中，选择一个元素作为”基准”（pivot），或者叫比较值
    - 数列中所有元素都和这个基准值进行比较，如果比基准值小就移到基准值的左边，如果比基准值大就移到基准值的右边
    - 以基准值左右两边的子列作为新数列，不断重复第一步和第二步，直到所有子集只剩下一个元素为止
- 实现细节
    - 基准的选择：如果待排序数据已经排好序的，选择了第一个或者最后一个数，就会产生一个很糟糕的分割。几乎所有的数据都被分割到一个集合中，而另一个集合没有数据。这样的情况下，时间花费了，却没有做太多实事。而它的时间复杂度就是最差的情况O(N^2)
        - 方法一：先打乱数组
        - 方法二：随机选择
        - 方法三：选择三数中值，随机选取三个元素，并用它们的中值作为整个数据中值的估计值
    - 将元素移动到基准两侧
        - 方法一
            - 将基准元素与最后的元素交换，使得基准元素不在被分割的数据范围
            - i和j分别从第一个元素和倒数第二个元素开始。i在j的左边时，将i右移，直到发现大于等于基准的元素，然后将j左移，直到发现小于等于基准的元素。i和j停止时，元素互换。这样就把大于等于基准的移到了右边，小于等于基准的移到了左边
            - 重复上面的步骤，直到i和j交错
            - 将基准元素与i所指向的元素交换，使得基准元素将整个元素集合分割为小于基准和大于基准的元素集合
        - 方法二
            - 三路划分
- 缺点
    - 非常脆弱，在实现时要非常小心才能避免低劣的性能
    - 对于小规模的数据集性能不是很好
    - 非稳定排序
    - 有递归开销
- https://zhuanlan.zhihu.com/p/57436476
- https://www.zhihu.com/question/24633412


### 优先队列

- 场景：计算topK，不需要全部排序
- 操作：删除最大元素和插入元素
- 实现
    - 无序数组
    - 有序数组
    - 链表
    - 二叉堆
        - 插入元素
            - 新元素加到数组末尾，增加堆的大小，并让这个元素**上浮**到合适的位置
        - 删除最大元素
            - 从数组顶端删去最大的元素，将数组的最后一个元素放到顶端，减小数组的大小，并让这个元素**下沉**到合适的位置
        - 从Ｎ个输入中找到最大的Ｍ个元素所需成本
            - 时间复杂度：Ｏ(NlogM)
            - 空间复杂度：Ｏ(M)
- **二叉堆**
    - 一组能够用堆有序的**完全二叉树**排序的元素，并在数组中按层级存储（不使用数组的第一个元素）   
        - 堆有序：**每个结点都大于等于它的两个子结点**
        - 一棵大小为Ｎ的完全二叉树的高度为lgN
- 堆排序
    - 堆的构造
        - 从右至左用sink()函数构造子堆
    - 下沉排序 
        - 从堆中按递减顺序取出所有元素并得到排序结果


>插入排序、归并排序、堆排序、快速排序这四种排序算法，他们的运行时间上界不会超过O(nlgn)。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序算法称为**比较排序**。

>可以证明，基于比较的排序算法在最坏情况下的时间下界是Ω(nlgn)。堆排序和归并排序的运行时间上界为O(nlgn)，因此这两种排序算法都是渐进最优的比较排序算法。

>下面，我们探究比较排序以外的排序算法，这些算法可以摆脱下界Ω(nlgn)的限制，达到线性时间复杂度O(n)。


### 计数排序
- **假设n个输入元素中的每一个都是在0到k区间内的一个整数**
- 步骤
    - 第一步：找出原数组中元素值最大的，记为max
    - 第二步：创建一个新数组count，其长度是max加1，其元素默认值都为0
    - 第三步：遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值
    - 第四步：创建结果数组result，起始索引index
    - 第五步：遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素
    - 第六步：返回结果数组result


### 桶排序（bucket sort）

- 计数排序的升级版
- **假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序**
- 在内存中开辟max_num（序列中的最大值）+1的空间当做多个桶。序列中出现一个数字num，处于某一个范围，那就把数字num加入对应的桶
- 如果数据分布得很均匀，每个桶中的数据就不会太多，都会维持在常数量级
- 先对每个桶中的元素排序，然后把所有桶中的元素顺序列出来即可

### 基数排序

- 按照每一位对它们进行排序


### Timsort




### 参考资料

- Algorithms，Robert Sedgewick 
- https://www.cnblogs.com/xxtalhr/p/10768593.html
- https://www.cnblogs.com/levylovepage/p/11564166.html
- https://www.jianshu.com/p/ff1797625d66
- https://www.cnblogs.com/xiaochuan94/p/11198610.html
