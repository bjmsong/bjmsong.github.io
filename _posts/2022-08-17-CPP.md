---
layout:     post
title:      CPP
subtitle:   
date:       2022-08-17
author:     bjmsong
header-img: 
catalog: true
tags:
    - C++
---
## from b站 HexUp
### 类型声明规则
1. 找到变量名，如果没有变量名，找到最里面的结构
2. 向右看，读出你看到的东西，但是不要跳过括号
3. 再向左看，读出你看到的东西，但是不要跳过括号
4. 如果有括号的话，跳出一层括号

```C
int *v[5]; // v是一个数组，里面的元素是指针，指针指向int类型变量
int (*v)[5]; // v是一个指针，指向int类型的数组
int (*func)(); // func是一个函数指针，指向返回int值的函数
int (*v[])();  // v是一个数组，里面的元素是指针，指向返回int值的函数
```

### 指针的大小
- 指针就是内存地址
- 指针的大小 = 等于内存地址的大小
    - 32位机器：32 bit = 4 Byte
    - 64位机器：64 bit

### Lambda表达式: 匿名函数

```C
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    vector<int> vec {10, 0, 3, 7, 6, 20};

    auto f = [](int a, int b){
        return a<b;
    };

    sort(vec.begin(), vec.end(), f);

    // 捕获变量：让匿名函数可以访问/修改外部变量
    int N = 100, M = 10;

    auto g = [N, &M](int i) {
        M = 20;
        return N * i;
    }

    cout << g(10) << endl;
    cout << M << endl;
} 
```
### 内存泄露

```C
// 栈内存，编译器负责分配和释放（作用域结束则自动释放）
int a = 100;
int* p = &a;

// 堆内存，程序员手动分配和释放
// p是栈内存上定义的，指向堆内存的地址
int *p = new int;
delete p;    // 释放了p指向的内存，不是删除p本身，p还可以指向别的地方
p = &a;

// 内存泄露：堆内存没有释放
```

- 对于一个指针不要删两次，这个属于undefined behavior
- C++11引入了nullptr

```C
int *p = new int;
delete p;
p = nullptr;
...

// 验证p是否可用,用nullptr比NULL更好，因为nullptr是类型安全的，某些情况下编译器会把null和int类型搞混
if (p!=nullptr)
{
    ...
}
```

- 栈内存：stack
    - 为线程留出的临时空间，每一个线程都有固定的栈空间，栈空间存储的数据只能被当前线程访问
    - 栈空间的分配和回收是由系统来做的，不需要手动控制
    - 函数调用时，系统会为这个函数的调用分配栈空间，当函数返回后，系统就会自动回收这块空间
- 堆内存：heap
    - 大小不固定，可以动态扩容，程序员动态分配，更加灵活
    - 生存周期比栈内存更久
    - 容易产生内存泄露
    - 容易产生内存碎片
    - 线程不安全：可以被一个进程内的所有线程访问
- 堆内存 vs 栈内存
    - 栈内存
        - 分配内存速度：快
            - 直接移动栈上的指针即可
        - 空间管理：高效，不会产生碎片
        - 访问权限：只能局部变量
        - 空间大小限制：操作系统限制
        - 内存分配：连续
        - 分配和释放：编译器自动管理
        - 开销：低
        - 主要问题：空间小
        - 灵活性：固定大小（~2MB）
    - 堆内存
        - 分配内存速度：慢
            - 要做很多事情
        - 空间管理：会产生内存碎片
        - 访问权限：可以访问全局变量
        - 空间大小限制：没有特定的限制
        - 内存分配：随机
        - 分配和释放：程序员手动管理
        - 开销：高
        - 主要问题：内存碎片
        - 灵活性:可以resize
- 大内存使用堆，小内存使用栈
- 《Memory management in C: The heap and the stack》

### 智能指针
- shared_ptr：共享指针
    - 引用计数：记录有多少个共享指针指向这个对象，当指针数量为0时，程序会自动释放这个对象
        - 有额外性能开销
        - 避免跟裸指针混用：哪怕还有裸指针指向这个对象，仍然会被释放

    ```C
    #include <memory>
    using namespace std;
    
    shared_ptr<int> p;
    // 推荐使用的初始化方式：效率更高，更安全
    p = make_shared<int>(100); // 动态分配内存，p指向这块内存
    // 也可以用new初始化shared_ptr
    shared_ptr<int> p {new int(100)}

    // shared_ptr的使用跟普通指针一致
    ```

- unique_ptr：独享指针

    ```C
    #include <memory>
    using namespace std;

    unique_ptr<int> up = make_unique<int>(100);
    ```
    
    - 零开销的智能指针
    - unique_ptr销毁或释放的时候，其绑定的资源也会自动释放，不再需要手动释放
        - 即便抛出异常，资源最后也会被释放
    - 独享:不支持复制操作，但是可以转移
        - 在函数间传递unique_ptr

        ```C
        void pass_up(unique_ptr<int> up)
        {
            cout << "In pass_up: " << *up << endl;
        }

        void pass_up_value(int& value)
        {
            cout << "In pass_up_value: " << value << endl; 
        }

        void pass_up_naked(int* p)
        {
            cout << "In pass_up_naked: " << *p << endl;  
        }

        void pass_up_1(unique_ptr<int>& up)
        {
            cout << "In pass_up_1: " << *up << endl；
            up.reset();
        }

        void pass_up_2(unique_ptr<int> up)
        {
            cout << "In pass_up_2: " << *up << endl；
        }

        void main()
        {
            auto up = make_unique<int>(123);
            pass_up(up);  // 编译错误，因为传值调用，会复制up，unique_ptr不允许复制

            // 访问up对应的资源
            pass_up_value(*up); 
            pass_up_naked(up.get());  // 传入up的裸指针

            // 访问up
            pass_up_1(up);
            if (up == nullptr) cout << "up is reset" << endl;

            pass_up_2(move(up));  // 转移up
        }
        ```

    - 使用方法跟裸指针类似

- weak_ptr
    - 

## 代码规范
- 华为c语言编程规范
- 微软一站式编码标准
- google style
- black：格式化python代码
https://mp.weixin.qq.com/s/B2f_HsZcLN-wdnZ_x6vIHg

## 对象大小
- 成员变量占内存，成员函数不占内存
- 空类占1个字节（占位符）
- 虚函数指针占4个字节
- 内存对齐
https://www.bilibili.com/video/BV1U7411e7ip/?spm_id_from=333.999.0.0&vd_source=7798c62f92ce545f56fd00d4daf55e26

## 学习路线
https://www.bilibili.com/read/cv9643827?spm_id_from=333.999.0.0
https://www.bilibili.com/read/cv8194315?spm_id_from=333.999.0.0

## 常用网站
cppreference
CppCon
https://www.cplusplus.com/
https://www.reddit.com/r/cpp/
https://en.wikibooks.org/wiki/C++_Programming
https://www.thefreecountry.com/sourcecode/cpp.shtml
www.learncpp.com


## 公开课
https://medium.com/swlh/introduction-to-programming-paradigms-aafcd6b418d6
    programming paradigms stanford，编程范式
youtube 
    cs106x
        配套教材：Programming Abstractions in C++
    https://www.youtube.com/watch?v=Rub-JsjMhWY&ab_channel=DerekBanas
https://www.youtube.com/watch?v=vLnPwxZdW4Y&ab_channel=freeCodeCamp.org
https://medium.com/javarevisited/top-10-courses-to-learn-c-for-beginners-best-and-free-4afc262a544e
“Learning and Teaching Modern C++” Talk by Bjarne Stroustrup


## 书
C++ Primer
How to Think Like a Computer Scientist: C++ Version
a tour of c++
https://www.zhihu.com/question/34267829
https://www.cnblogs.com/xiaofengkang/archive/2011/05/16/2048262.html
Programming: Principles and Practice Using C++
Data Structures and Algorithms in C++
The C++ Programming Language
STL源码剖析
- the C++ programming language
- effective modern c++
- More Effeetive C++
- C++标准程序库
- 深入探索C++对象模型
- C++ in a Nutshell
- Accelerated C++: Practical Programming by Example
- Essential C++ (C++ In-Depth Series) 
https://www.zhihu.com/question/23447320/answer/39322848
https://www.reddit.com/r/cpp_questions/comments/9nsr0r/c_primer_vs_a_tour_of_c/
https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/388282#388282
https://www.zhihu.com/question/23447320
https://zhuanlan.zhihu.com/p/21472075
http://www.sunistudio.com/cppfaq/

## 代码
https://github.com/fffaraz/awesome-cpp
https://github.com/Light-City/CPlusPlusThings
https://www.zhihu.com/question/23153437/answer/2681460504


### 性能优化
https://zhuanlan.zhihu.com/p/33638344?utm_source=wechat_timeline&utm_medium=social&utm_oi=72535160913920&utm_campaign=shareopn


## 无锁编程之RCU与风险指针
- 问题
    - 内存可见
    - 指令重排：编译器重排、cpu重排(runtime)
- 类似
    - 智能指针
    - double buffer
- 内存序


##
https://mp.weixin.qq.com/s/b_xlJF1-Cplgs-uawWuUow
https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/
共享变量，加锁，静态计数器
https://eel.is/c++draft/
https://medium.com/@dmitryrastorguev/teach-yourself-c-where-to-start-ce496538c608
https://mp.weixin.qq.com/s/UW2Ual0v21KNQz60MHT1nQ
https://www.bilibili.com/video/BV1T341127SK/?spm_id_from=333.999.list.card_archive.click&vd_source=7798c62f92ce545f56fd00d4daf55e26
https://github.com/Light-City/CPlusPlusThings
https://github.com/fffaraz/awesome-cpp
https://www.zhihu.com/question/67158058
https://blog.csdn.net/qq_42366672/article/details/122943977
https://www.zhihu.com/question/40131963
https://github.com/youngyangyang04/TechCPP
- C++写一个服务
https://www.bilibili.com/video/BV1hV4y1J7Ls?spm_id_from=333.337.search-card.all.click&vd_source=7798c62f92ce545f56fd00d4daf55e26
https://hkrb7870j3.feishu.cn/docx/doxcn4Qjv9EXC24N8817CyEQwwh
https://github.com/oldjun/yazi
https://github.com/linyacool/WebServer
https://blog.csdn.net/datase/article/details/80066025?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-80066025-blog-83830108.pc_relevant_aa&spm=1001.2101.3001.4242.2&utm_relevant_index=4
https://blog.csdn.net/qq_29695701/article/details/83830108
异步编程，模块解耦，跨语言集成，平台无关编码，设备相关宏编译，日志系统，平滑升级
https://www.w3schools.com/cpp/
https://www.programiz.com/cpp-programming
