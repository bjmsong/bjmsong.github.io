---
layout:     post
title:      The C Programming Language
subtitle:   
date:       2022-10-06
author:     bjmsong
header-img: 
catalog: true
tags:
    - C++
---
## code
https://github.com/bjmsong/The-C-Programming-Language-2nd-Edition

## 1. 导言
- 编译，生成可执行文件： cc filename1.c filename2.c filename3.c
- 所有变量必须先声明后使用
    - 可以在声明的同时进行初始化
- 符号常量： #define 名字 替换文本
- 空语句：单独的分号
- 函数参数
    - 传值调用：传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中
        - 被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值
    - 如果要修改主调函数中的变量，调用者需要向被调用函数提供待设置值的变量的地址(指针)，被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量
    - 如果参数是数组，传递给函数的值是数组起始元素的地址，它并不复制数组元素本身。在被调用函数中，可以通过数组下标访问或修改数组元素的值。
- 字符串常量以'\0'结尾
- 通常把变量和函数的external声明放在头文件中，并在源文件的开头把头文件include进来
- 声明(declaration)：说明变量的属性，但不分配存储单元
- 定义(define)：除此之外还将分配存储单元

## 2. 类型、运算符与表达式
- 变量名使用小写字母，符号常量名使用大写字母
- 基本数据类型
    - char: 字符型，占用一个字节，可以存放本地字符集中的一个字符
    - int：整型，通常反映了所用机器中整数的最自然长度
    - float: 单精度浮点型
    - double: 双精度浮点型
- short(通常为16位)，long(通常为32位)可以用于限定整型
- signed,unsigned可以用于限定char类型或任何整型
- 枚举
- const限定符指定变量的值不能被修改
- 算术运算符、关系运算符、逻辑运算符、按位运算符
- 类型转换
    - 自动转换：把"比较窄的"操作数转换为"比较宽的"操作数，不丢失信息
    - char类型就是较小的整型，在算术表达式中可以自由使用char类型的变量
    - 当表达式中包含unsigned类型的操作数时，转换规则要复杂一些。主要原因在于，带符号值与无符号值之间的比较运算是与机器相关的，它们取决于机器中不同整数类型的大小。
- 赋值运算符
    - 赋值语句具有值，且可以用在表达式中。赋值表达式的类型是它的左操作数的类型，其值是赋值完成后的值。
- 条件表达式


## 3. 控制流
- if-else
- switch
- while，for循环
- break: 从循环中提前退出
- continue：开始下一次循环的执行

## 4. 函数与程序结构
- 最简单的函数 dummy() {}
    - 用于在程序开发期间保留位置
- 不允许在一个函数中定义其他函数
- 外部变量
    - 可以在全局范围内访问，函数可以通过外部变量交换数据
    - 必须定义在所有函数之外，且只能定义一次
    - 过度依赖外部变量会导致一定的风险：外部变量的值可能会被意外地修改
- 作用域规则
    - 名字的作用域指的是程序中可以使用该名字的部分
    - 外部变量或函数的作用域从声明它的地方开始
    - 一个外部变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它。外部变量的定义中必须指定数组的长度，但extern声明则不一定要指定数组的长度。
- 头文件
    - 多个源文件时，把公共的定义和声明放在一起，形成头文件
- 静态变量
    - 用static声明限定外部变量和函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分
        - 可以达到隐藏外部对象的目的
    - 用static声明内部变量，不管其所在函数是否被调用，它一直存在
- 寄存器变量
    - register声明告诉编译器，它所声明的变量在程序中使用频率较高，可以将register变量放在寄存器中
        - 利用缓存使得程序更小，速度更快
    - 只适用于自动变量以及函数的形参
    - 编译器可以忽略过量的或不支持的寄存器变量声明
- 程序块结构
    - 应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，可能引起混乱和错误
- 初始化
    - 不显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值没有定义
    - 外部变量和静态变量：初始化表达式必须是常量表达式
    - 自动变量和寄存器变量：初始化表达式可以不是常量表达式，表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用
- 递归
    - 函数直接或间接调用自身
    - 递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈
    - 递归的执行速度不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解
- C预处理器
    - 预处理器是编译过程中单独执行的第一个步骤
    - #include: 在编译期间把指定文件的内容包含进当前文件中
        - 复制-粘贴
    - #define: 用任意字符序列替代一个标记
        - 宏替换
        - #undef: 取消名字的宏定义
    - 条件包含
        - #if

## 5. 指针与数组
- 指针：保存地址的变量
- 指针与地址
    - 指针只能指向某种特定类型的对象，void类型的指针可以存放指向任何类型的指针

```C
int x=1,y=2,z[10];
int *ip;  // ip是指向int类型的指针

ip = &x; // ip指向x
y = *ip; // y现在值为1
*ip = 0; // x现在值为0
ip = &z[0]; // ip现在指向z[0]

iq = ip; // 指针iq也指向ip指向的对象
```

- 指针与函数参数

```C
// px=&a,py=&b
void swap(int *px, int *py)
{
    int temp;

    temp = *px;
    *px = *py;
    *py = temp;
}

swap(&a, &b);
```

- 指针与数组
    - 通过数组下标所能完成的任何操作都可以通过指针来实现
    - 指针是一个变量，但数组名不是一个变量

    ```C
    int a[10];
    int *pa;
    pa = &a[0]; // 也可以写成 pa = a;
    pa+i // 指向a数组的第i个元素

    a[i] // 会先转换为*(a+i)
    &a[i] // a之后第i个元素的地址，和a+i的含义相同
    ```

    - 习惯于将指针作为数组的形参

    ```C
    int strlen(char *s)     // char *s 和 char s[]是等价的
    {
        int n;
        for (n=0; *s != '\0'; s++)
            n++;
        return n;
    }

    strlen("hello, world");
    strlen(array);  // array:字符数组
    strlen(ptr);    // ptr: 是一个指向char类型对象的指针
    ```

- 地址算术运算
    - p++, p+=i

    ```C
    #define ALLOCSIZE 10000

    static char allocbuf[ALLOCSIZE];
    static char *allocp = allocbuf; // 下一个空闲位置

    char *alloc(int n)
    {
        if (allocbuf + ALLOCSIZE - allocp >= n) //有足够的空间空间
        {
            allocp += n;
            return allocp - n;            
        }
        else
            return 0;
    }

    void afree(char *p) // 释放p指向的存储区
    {
        if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
            allocp = p;
    }
    ```

    - 如果指针p和q指向同一个数组的成员，那么它们之间就可以进行关系比较运算
- 字符指针与函数
    - 字符串常量是一个字符数组，以'\0'结尾

    ```C
    char amessage[] = "now is the time"; // 定义一个数组
    char *pmessage = "now is the time";  // 定义一个指针
    ```

    ```C
    // 将指针t指向的字符串复制到指针s指向的位置：使用数组下标实现的版本
    void strcpy(char *s, char *t)
    {
        int i;

        i = 0;
        while ((s[i] = t[i]) != '\0')
            i++;
    }

    // 使用指针方式实现的版本1
    void strcpy(char *s, char *t)
    {
        while ((*s = *t) != '\0'){
            s++;
            t++;
        }
    }

    // 使用指针方式实现的版本2
    void strcpy(char *s, char *t)
    {
        while ((*s++ = *t++) != '\0')
            ;
    }

    // 使用指针方式实现的版本3
    void strcpy(char *s, char *t)
    {
        while (*s++ = *t++)
            ;
    }
    ```

- 指针数组以及指向指针的指针
    - 指针本身也是变量，它们也可以像其他变量一样存储在数组中
- 多维数组
- 指针数组的初始化
- 指针与多维数组
    ```C
    // 真正的二维数组，分配了200个int类型长度的存储空间
    int a[10][20];

    // 分配了10个指针，并且没有对它们初始化
    int *b[10];
    ```
- 命令行参数
    - 第一个参数：argc，表示命令行中参数的数目
        - argc至少为1
    - 第二个参数：argv，指向字符串数组的指针，其中每个字符串对应一个参数
        - argv[0]是启动该程序的程序名
- 指向函数的指针
    - 这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值
- 复杂声明


## 6. 结构(struct)
- 结构的基本知识
    - 一个或多个变量的集合，这些变量可以为不同的类型，用于组织复杂的数据
    - 结构名.成员
- 结构与函数
    - 合法操作
        - 作为一个整体复制和赋值
        - 取地址：&
        - 访问其成员
    - p是一个指向结构的指针，可以用: p->结构成员
- 结构数组
    - sizeof: 对象或类型占用的存储空间字节数
- 指向结构的指针
    - 指针之间的加法运算是非法的，减法运算是合法的
- 自引用结构
    - 递归
- 表查找
- 类型定义(typedef)
    - 建立新的数据类型名
        - 表达方式更简洁
        - 使得程序参数化，提高程序的可移植性
            - 如果typedef声明的数据类型与机器相关，当程序移植到其它机器时，只需要改变typedef类型定义就可以了
                - 例如标准库的size_t
        - 为程序提供更好的说明性
- 联合(union)
    - 是可以(在不同时刻)保存不同类型和长度的对象的变量

    ```C
    union u_tag {
        int ival;
        float fval;
        char *sval;
    }
    ```
- 位字段

## 7. 输入与输出
- 标准输入/输出
    - 文本流由一系列行组成，每一行的结尾是一个换行符
    - int getchar(void) 
        - 从标准输入中读入下一个输入字符，并将其作为结果值返回
        - 若遇到文件结尾，则返回EOF
    - < : 重定向
    - 管道重定向 
    - int putchar(int)
        - 将字符送至标准输出上
- 格式化输出(printf)
- 变长参数表
    - ...出现在参数表的尾部，表示参数表中的数量和类型是可变的
- 格式化输入(scanf)
- 文件访问
    ```C
    FILE *fp;
    FILE *fopen(char *name, char *mode);

    // 从文件中返回下一个字符
    int getc(FILE, *fp);
    // 将字符c写入到fp指向的文件中
    int putc(int c, FILE *fp);

    int fclose(FILE *fp);
    ```
    - 启动一个C语言程序时，操作系统环境负责打开3个文件(标准输入、标准输出、标准错误)，并将这3个文件的指针(stdin,stdout,stderr)提供给该程序
        - 一般情况下，stdin指向键盘，stdout/stderr指向显示器，它们可以被重定向到文件或管道
- 错误处理: stderr, exit
    - exit(expr):将终止调用程序的执行，任何调用该程序的进程都可以获得exit的参数值
- 行输入和行输出
    ```C
    // 从fp指向的文件中读取下一个输入行
    char *fgets(char *line, int maxline, FILE *fp);

    // 将一个字符串写入到一个文件中
    int fputs(char *line, FILE *fp);
    ```
- 其他函数
    - 字符串操作函数
    - 字符类别测试和转换函数
    - ungetc
    - 命令执行函数
    - 存储管理函数
    ```C
    // 动态地分配存储块
    // 返回一个指针，该指针指向n字节长度的未初始化的存储空间
    void *malloc(size_t h);

    void *calloc(size_t n, size_t size);

    // 释放p指向的存储空间，p是通过malloc或calloc函数得到的指针
    free(p);
    ```
    - 数学函数
    - 随机数发生器函数

## 8. Unix系统接口
- 使用系统调用可以获得最高的效率，或者访问标准库中没有的功能
- 文件描述符
    - Unix中所有的外围设备(如键盘、显示器)都被看作是文件系统的文件。因此，所有的输入/输出都要通过读写文件完成。
    - 通过文件描述符标识文件，而不是文件名
    - 0：标准输入
    - 1：标准输出
    - 2：标准错误
- 低级IO: read,write
    ```C
    int n_read = read(int fd, char *buf, int n);
    int n_written = write(int fd, char *buf, int n);
    ```
- open,create,close,unlink
- 随机访问:lseek

## 附录A. 参考手册

## 附录B. 标准库
- 输入与输出: <stdio.h>
- 字符类别测试: <ctype.h>
- 字符串函数：<string.h>
- 数学函数：<math.h>
- 实用函数：<stdlib.h>
- 诊断：<assert.h>
- 可变参数表：<stdarg.h>
    - 提供了遍历未知数目和类型的函数参数表的功能
    - 包含一组宏定义，该文件的实现因不同机器而不同，但提供的接口是一致的
        - va_list
        - va_start
        - va_arg
        - va_end
- 非局部跳转：<setjmp.h>
- 信号：<signal.h>
- 日期与时间函数：<time.h>
- 与具体实现相关的限制：<limits.h>, <float.h>



