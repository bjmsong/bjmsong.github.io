---
layout:     post
title:      算法与数据结构之二
subtitle:   排序算法
date:       2019-11-25
author:     bjmsong
header-img: img/Algo/algo.jpg
catalog: true
tags:
    - 算法
---
>本文将介绍排序算法，包括插入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时还会介绍另外一些算法，用于解决跟排序相关的问题，包括优先队列、选举以及归并。

## 排序算法
|          | 时间复杂度 | 空间复杂度 |
| -------- | ---------- | ---------- |
| 冒泡排序 |       O（n^2）     |     O(1)       |
| 插入排序 |      O(n^2)      |         O(1)     |
| 选择排序 |         O（n^2）   |       O(1)     |
| 希尔排序 |            |            |
| 归并排序   |            |            |
| 快速排序         |            |            |
| 堆排序         |            |            |

### 初级排序算法
- 选择排序
    - 遍历数组，找到最小的元素，和数组的第一个元素交换顺序
- 插入排序
    - 遍历数组，依次跟左边的元素比较，保证左边始终有序
    - 所需时间取决于输入元素中的初始顺序
        - 对部分有序的数组比较高效
        - 随机排序：N^2
- 希尔排序
    - 基于插入排序
    - 使数组中任意间隔为h的元素都是有序的
    - h从N/3开始递减到1
    - 比插入排序和选择排序快得多，且不需要额外空间
- 冒泡排序
- Comparable接口

### 归并排序
- 先递归地将数组分成两半，分别排序，然后将结果归并起来
- 原地归并：实现非常复杂
- 自顶向下归并
    - 分治思想(divide and conquer)
- 自底向上的归并
    - 外层循环：子数组大小(1,2,4,..)
    - 内层循环：子数组索引
- 时间复杂度：NlogN
- 缺点：额外空间和N成正比

### 快速排序：最快的通用排序算法
- 原地排序
- 时间复杂度：NlogN
- step1：切分，保证切分元素左边的元素都不大于切分元素，右边的元素都不小于切分元素
    - 选a[lo]作为切分元素
    - 从左端开始扫描，从右端开始扫描，然后交换元素
    - 两个指针相遇，将切分元素a[lo]和左子数组最右边的元素交换
- step2：递归排序切分好的数组

### 计数排序

### 优先队列
- 计算topK，不需要全部排序
- 操作：删除最大元素和插入元素
- 实现
    - 无序数组
    - 有序数组
    - 链表
    - 二叉堆
        - 插入元素
            - 新元素加到数组末尾，增加堆的大小，并让这个元素**上浮**到合适的位置
        - 删除最大元素
            - 从数组顶端删去最大的元素，将数组的最后一个元素放到顶端，减小数组的大小，并让这个元素**下沉**到合适的位置
- **二叉堆**
    - 一组能够用堆有序的**完全二叉树**排序的元素，并在数组中按层级存储（不使用数组的第一个元素）   
        - 堆有序：**每个结点都大于等于它的两个子结点**
- 堆排序
    - 堆的构造
        - 从右至左用sink()函数构造子堆
    - 下沉排序 
        - 从堆中按递减顺序取出所有元素并得到排序结果
    - 应用很少，因为它无法利用缓存
- heapq（python）
    - 二叉树
    - 最小堆：每个父节点的值都小于所有子节点的值，即heap[0]表示最小的元素
    - 方法：heappush，heappop（弹出并返回heap的最小的元素，并保持堆的不变性）


## 参考资料
- Algorithms，Robert Sedgewick 
