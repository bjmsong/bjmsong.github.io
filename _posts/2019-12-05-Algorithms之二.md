---
layout:     post
title:      Algorithms之二
subtitle:   排序算法
date:       2019-12-05
author:     bjmsong
header-img: img/Algo/algorithms.jpg
catalog: true
tags:
    - 算法
---
>本文将介绍排序算法，包括插入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时还会介绍另外一些算法，用于解决跟排序相关的问题，包括优先队列、选举以及归并。



### 排序算法总结

| 最坏情况 | 是否稳定 | 是否为原地排序 | 时间复杂度 | 空间复杂度 |
| -------- | ---------- | ---------- | ---------- | ---------- |
| 选择排序 |     否     |     是     |      N^2     |     1       |
| 插入排序 |      是      |      是      |      介于N和N^2之间      |         1     |
| 冒泡排序 |      否   |      是   |       N^2   |       1     |
| 希尔排序 | 否 | 是 | ？ | 1 |
| 归并排序   | 是 | 否 | NlogN | N |
| 快速排序         | 否 | 是 | NlogN | logN |
| 堆排序         | 否 | 是 | NlogN | 1 |

- 稳定性：保留数组中重复元素的相对位置



### 初级排序算法

- 选择排序
    - 遍历数组，找到最小的元素，和数组的第一个元素交换顺序
    - 运行时间和输入无关
    - 数据移动是最少的，交换次数和数组的大小是线性关系
- 冒泡排序
    - 依次比较相邻元素，把最大的元素逐步移动到末尾
    - 和选择排序类似，每一轮都是把最大/最小的元素找出来，只是找的方式有些区别
- 插入排序
    - 遍历数组，依次跟左边的元素比较，保证左边始终有序 
    - 就像理牌一样
    - 运行时间取决于输入元素中的初始顺序
        - 对部分有序的数组比较高效
        - 最坏情况：N^2/2次比较，N^2/2次交换
        - 最好情况：N-1次比较，0次交换
- 希尔排序
    - 基于插入排序
    - h有序：使数组中任意间隔为h的元素都是有序的
    - h从N/3开始递减到1
    - 比插入排序和选择排序快得多，且不需要额外空间，代码量很小



### 归并排序
- 先递归地将数组分成两半，分别排序，然后将结果归并起来

- 自顶向下归并
  
    - 分治思想(divide and conquer)
    
- 自底向上的归并
    - 外层循环：子数组大小(1,2,4,..)
    - 内层循环：子数组索引
    
- 缺点：额外空间和N成正比

    - 原地归并：实现非常复杂

- python有一个模块，专门提供了归并排序的方法，叫做“heapq”模块

    ```python
    from heapq import merge
    
    def merge_sort(lst):
        if len(lst) <= 1:
            return lst          # 从递归中返回长度为1的序列
        middle = len(lst) // 2
        left = merge_sort(lst[:middle])     # 通过不断递归，将原始序列拆分成n个小序列
        right = merge_sort(lst[middle:])
        return list(merge(left, right))
    
    
    merge_sort([11, 99, 33 , 69, 77, 88, 55, 11, 33, 36,39, 66, 44, 22])
    
    # 返回结果[11, 11, 22, 33, 33, 36, 39, 44, 55, 66, 69, 77, 88, 99]
    ```

    



### 快速排序：最快的通用排序算法
- 快速排序(quick sort)采用了分治的策略。由C. A. R. Hoare在1962年提出，被誉为二十世纪科学和工程领域的十大算法之一。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
- 快排的原理可以看下以下两个视频
    - [罗马尼亚舞团舞蹈](https://www.bilibili.com/video/av16290537?from=search&seid=10248348647103581642)
    - [TED-ed](https://www.bilibili.com/video/av10076626/?spm_id_from=333.788.videocard.18)
- 算法步骤
    - 在数列之中，选择一个元素作为”基准”（pivot），或者叫比较值
    - 数列中所有元素都和这个基准值进行比较，如果比基准值小就移到基准值的左边，如果比基准值大就移到基准值的右边
    - 以基准值左右两边的子列作为新数列，不断重复第一步和第二步，直到所有子集只剩下一个元素为止
- 缺点
    - 非常脆弱，在实现时要非常小心才能避免低劣的性能
    - 对于小规模的数据集性能不是很好



### 计数排序

- O(n)
- https://www.cnblogs.com/xiaochuan94/p/11198610.html



### 桶排序（bucket sort）

- 在内存中开辟max_num（序列中的最大值）+1的空间当做多个桶。序列中出现一个数字num，那就找到对应的桶，加1。常见的排序算法中，桶排序可以说是速度最快的一种排序算法了（不过本人做过一些测试桶排序速度在今天已经不如Timsort等排序算法），当然内存的占用不可避免。



### Timsort





### 优先队列

- 场景：计算topK，不需要全部排序
- 操作：删除最大元素和插入元素
- 实现
    - 无序数组
    - 有序数组
    - 链表
    - 二叉堆
        - 插入元素
            - 新元素加到数组末尾，增加堆的大小，并让这个元素**上浮**到合适的位置
        - 删除最大元素
            - 从数组顶端删去最大的元素，将数组的最后一个元素放到顶端，减小数组的大小，并让这个元素**下沉**到合适的位置
        - 从Ｎ个输入中找到最大的Ｍ个元素所需成本
            - 时间复杂度：Ｏ(NlogM)
            - 空间复杂度：Ｏ(M)
- **二叉堆**
    - 一组能够用堆有序的**完全二叉树**排序的元素，并在数组中按层级存储（不使用数组的第一个元素）   
        - 堆有序：**每个结点都大于等于它的两个子结点**
        - 一棵大小为Ｎ的完全二叉树的高度为lgN
- 堆排序
    - 堆的构造
        - 从右至左用sink()函数构造子堆
    - 下沉排序 
        - 从堆中按递减顺序取出所有元素并得到排序结果
    - **应用很少，因为它无法利用缓存**
- python模块heapq
    - 二叉树
    - 最小堆：每个父节点的值都小于所有子节点的值，即heap[0]表示最小的元素
    - 方法：heappush，heappop（弹出并返回heap的最小的元素，并保持堆的不变性）



### 参考资料

- Algorithms，Robert Sedgewick 
- https://www.cnblogs.com/xxtalhr/p/10768593.html
- https://www.cnblogs.com/levylovepage/p/11564166.html
