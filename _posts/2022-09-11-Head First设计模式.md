---
layout:     post
title:      Head First设计模式
subtitle:   
date:       2022-09-11
author:     bjmsong
header-img: img/cs/design pattern.jpg
catalog: true
tags:
    - 设计模式
---
## 设计原则
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
- 针对接口编程，而不是针对实现编程
    - 针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。因为代码是针对接口而写，通过多态，它可以与任何新类实现该接口
- 多用组合，少用继承
    - 组合：将类结合起来使用
- 为了交互对象之间的松耦合设计而努力
- 类应该对扩展开放，对修改关闭
- 依赖倒置：要依赖抽象，不要依赖具体类
    - 变量不可以持有具体类的引用
    - 不要让类派生自具体类
    - 不要覆盖基类已实现的方法

## 设计模式入门
- 继承的问题
    - 超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为
    - 可以在不适合该行为的子类中，把新的行为覆盖掉。但是很麻烦，所有不适合的子类都要这么做
- 接口的问题
    - java接口不具有实现代码，继承无法达到代码的复用
- 策略模式
    - 定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户
- 设计模式被认为是历经验证的OO设计经验
- 设计模式让开发人员之间有共享的语言，能够最大化沟通的价值

## 观察者模式
- 定义了对象之间的一对多依赖，当一个对象改变状态，其他依赖者都会收到通知
- 主题(也就是可观察者)用一个共同的接口来更新观察者
- 观察者和可观察者之间用**松耦合**的方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口
- 观察者模式是JDK中使用最多的模式之一
- 实现观察者模式的方法不止一种，但是以包含Subject和Observer接口的类设计的做法最常见
- Java内置有观察者模式
    - java.util包: Observer接口、Observalbe类

## 装饰者模式
- 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
    - 装饰者和被装饰对象有相同的超类型
    - 可以用一个或多个装饰者包装一个对象
    - 既然装饰者和被装饰者有相同的超类型，所有在任何需要原始对象的场合，都可以用装饰过的对象代替它
    - 装饰者可以在所委托被装饰者行为之前与/或之后，加上自己的行为，以达到特定的目的
    - 对象可以在任何时候被装饰，所有可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象 
- 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂

## 工厂模式
- 所有工厂模式都用来封装对象的创建
    - 工厂处理创建对象的细节
    - 优点
        - 将创建对象的代码集中在一个对象或方法中，可以避免代码的重复，并且更方便以后的维护
        - 客户在实例化对象时，只需要依赖接口，而不是具体的类
    - 当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须改变代码
- 简单工厂不是一个设计模式，比较像是一种编程习惯
- 在设计模式中，所谓的”实现一个接口“并不一定表示写一个类，并利用implement关键词来实现某个Java接口。而是泛指实现某个超类型（可以是类或者接口）的某个方法
- 工厂方法模式
    - 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工程方法让类把实例化推迟到子类
    - 通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的
    - 包含：创建者类、产品类 
- 抽象工厂模式

## 单例模式
- 


## 代码
https://github.com/JakubVojvoda/design-patterns-cpp
https://github.com/bethrobson/Head-First-Design-Patterns
https://github.com/yaocoder/DesignPattern
https://github.com/mrlegowatch/HeadFirstDesignPatternsCpp


