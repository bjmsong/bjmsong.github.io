---
layout:     post
title:      算法与数据结构之一
subtitle:   
date:       2019-11-25
author:     bjmsong
header-img: img/Algo/algo.jpg
catalog: true
tags:
    - 算法
---
>本文首先将讲解用来实现、分析和比较算法的基本原则和方法。包括Java编程模型、数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析（union-find）



## Java编程模型

- **程序是对算法精确、优雅和完全的描述**
- 优先使用大多数现代编程语言所共有的语法
- **基础编程模型：描述和实现算法所用到的语言特性、软件库和操作系统**



### Java程序的基本结构

- **一段Java程序（类）要么是一个静态方法（函数）库，要么是定义了一个数据类型。**
- 基本语法
    - 原始数据类型：整数、浮点数、布尔值
    - 语句：声明、赋值、条件、循环、调用、返回
    - 数组
    - 静态方法：即函数，静态方法可以封装并重用代码，使我们可以用独立的模块开发程序
    - 字符串
    - 标准输入/输出
    - **数据抽象：封装和重用代码，使我们可以定义非原始数据类型，支持面向对象编程**



### Java基本语法

- 执行Java程序：先编译(javac)，再运行(java)

- **强类型语言**
    
    - 在使用变量之前，需要声明变量的名称和类型
        - 函数参数及返回值都要指定类型
    - 优点：开发阶段可以避免更多bug，运行效率更高
    
- **重载：同样的运算符对不同类型会执行不同的操作**

- **可见修饰符**

    - public
    - private
    - protected

- **复制数组**

    - 声明、创建并初始化一个新数组，然后将原数组元素逐个复制到新数组
    - 如果将一个数组赋予另一个变量（别名），两个变量会指向同一个数组

- **静态方法**
    
    - 修饰符： static
    - 参数、返回值、副作用（例如打印了一个值）
    - **方法的性质**
        - **方法的参数按值传递**：
          - 方法处理的是参数的值，而非参数本身。因此在静态方法中改变参数变量的值对调用者没有影响
          - 数组参数将会是原参数的别名，数组内容会改变
        - 方法名可以被重载
        - 方法只能返回一个值，但可以包含多个返回语句
        - 方法可以产生副作用：返回值可以是void
    - 递归
        - 调用自己
        - 代码更简洁、优雅
        - **递归总有一个最简单的情况**
        - **递归调用总是尝试去解决一个规模更小的问题**
        - **递归调用的父问题和尝试解决的子问题之间不应该有交集**
    - **静态方法库**（如Math）
        - 定义在一个Java类中的一组静态方法
        - 存放类的文件名和类名相同
        - 包含一个main方法
    - 模块化编程的优点
        - 每个模块代码大小适中
        - 可以共享和重用代码
        - 很容易用改进的实现替换老的实现
        - 可以为解决编程问题建立合适的抽象模型
        - 缩小调试范围
    - **单元测试**
        - 每个静态方法库都包含一个main()函数来测试库中的所有方法
        - 编成一个测试用例来对所有代码进行全面的测试
            - 用例：指代调用另一个库中的方法的程序
    
- API（应用程序编程接口）
    - 是调用和实现之间的契约，详细说明了每个方法的作用
    - **将调用和实现分离：除了API中给出的信息，调用者不需要知道实现的其他细节**
    - **应该将自己编写的每一个程序都当做一个日后可以重用的库**
        - 编写用例，在实现中将计算过程分解成可控的部分
        - 明确静态方法库和与之对应的API
        - 实现API和一个能够对方法进行独立测试的main()函数
    
- 字符串
    - 拼接:+
    - 类型转换:parseInt,toString
    - 自动转换
    - 命令行参数:
      - 程序能够接受从命令行传来的信息
      -  用法：java 库名 字符串,字符串会作为参数传递
    - 字符串的操作
    
- 输入输出
    - **程序从标准输入流中获得输入，写入到标准输出流中**
    
    - 重定向:> <
    
    - 管道:将一个程序的输出重定向为另一个程序的输入
    
        

### 二分查找

- 算法：输入有序数组，每次跟中间值比较，如果没有找到，则将数组分成两半

- 时间复杂度：lg(N)

- 应用：白名单过滤

  

## 数据抽象（面向对象编程）

- **数据类型：一组值和一组对这些值的操作的集合**
- 抽象数据类型（ADT）：能够对使用者隐藏数据表示
- 任意数据类型都能通过在API中包含特定的方法从Java的内在机制中获益
    - 如Java所有数据类型都会继承toString()方法来返回用String表示的该类型的值
- 使用抽象数据类型
    - 抽象数据类型源代码在同一个目录
    - 或者在标准Java库中
    - 或者可以import
    - 或者在classpath中



### 对象：承载数据类型的值的实体

- 特性
    - 状态：数据类型中的值
    - 标识：在内存中的位置
    - 行为：对数据类型的操作
- 创建对象（new）
    - 分配内存空间
    - 调用构造函数初始化对象的值
    - **返回该对象的一个引用**
        - 声明原始数据类型，返回的是值本身
- **赋值语句**
    - 别名：不会创建新的对象，而只是创建另一个指向某个已经存在的对象的引用
        - 所以改变赋值后的对象，也会改变原对象
        - 如果是原始数据类型，赋值是复制值，而不是引用
        - 别名是bug的常见原因
- 对象作为参数
    - 会改变原对象的值
- 对象作为返回值
    - 这样实际上就可以返回多个值
- 数组也是对象，所以数组的赋值机制跟对象是一致的，所有非原始数据类型都是对象



### 抽象数据类型的实现

- 类名跟文件名相同
- 实例变量
  - 定义数据类型的值
  - 每个实例变量对应着无数个值（每个实例对象都会有一个）
- 构造函数
  - 初始化实例变量
  - 名称和类名相同
  - 没有返回值，不需要指定返回值的类型（void也不需要）
  - 重载：可以有多个
- 实例方法
  - 不需要static关键字
  - 公共的：在API中说明
  - 私有的：用于辅助计算，用例无法使用
  - 某些实例方法的存在是为了尊重Java的习惯--继承的方法
- 静态方法
  - 单元测试用例：main
- 作用域
  - 参数变量：整个方法
  - 局部变量：当前代码段中它的定义之后的所有语句
  - 实例变量：整个类，如果跟局部变量冲突，可以使用this前缀来区分
- **实现步骤**
  - 定义API
  - 用一个Java类实现API的定义
  - 实现多个测试用例来验证前两步做的设计决定



### 实例方法 vs 静态方法

- 实例方法 
    - 不需要static关键字
    - 对象名.方法名
    - 作用：访问或者改变对象的值
- 静态方法
    - static关键字
    - 类名.方法名
    - 作用：计算返回值
    - 访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制



### 数据类型的设计

- 封装（Encapsulation）
    - 使用数据类型的实现封装数据，以简化实现、隔离用例开发
    - 将程序分解为能够独立开发和调试的小型模块，将修改代码的影响限制在局部区域
    - 保持模块之间的独立性（减少耦合）
    - 静态库可以更新，API保持不变
- **设计API**
    - 最重要，最有挑战
    - 设计API付出的时间都能从调试和代码复用所节省的时间中获得回报
    - 与抽象数据类型相关联的值，一系列构造函数和实例方法的目的和副作用的自然语言描述
    - 包含用例代码
    - 只为用例提供它们所需要的（敏捷开发也倡导先写用例，再写实现）
- **接口继承**
    - 继承机制：子类型
    - 接口
        - 一组公共的方法
        - 为两个本来没有关系的类建立联系
        - 这两个类都必须实现这些方法
        - 定义接口：interface
        - 引用接口：implements
    - **调用接口中的方法可以操作实现该接口的任意类型的对象**
    - 接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性
- 实现继承
    - 继承机制：子类
    - 继承父类的所有实例方法和实例变量
    - 可以重写父类的方法
    - Object:所有类的父类
    - extends
- 封装类型
    - 每个原始数据类型都有一个对应的封装类型
      - 如：int -> Integer
    - 在需要的时候Java会自动将原始数据类型转换为封装类型
      - 如int值需要和String连接时，它的类型会被转换为Integer并触发toString()方法
- 等价性（equals）
    - 自反性
    - 对称性
    - 传递性
- Java自动内存管理
    - 垃圾回收:将孤儿对象的内存释放，即回收所有无法被访问的对象的内存
- **不可变性**
    - 不可变数据类型：该类型的对象中的值在创建之后就无法再被改变，如String，Date
    - final修饰符
    - 优点：预防意外修改，也使程序的调试更加简单
    - 缺点：
        - 需要为每个值创建一个新对象
        - 只能用来保证原始数据类型的实例变量的不可变性，而无法用于引用类型的变量
- **契约式设计**
    - 异常(Exception)：用于处理不受我们控制的不可预见的错误
        - 最佳实践：一旦出错就立刻抛出异常，使定位出错位置更容易
    - 断言(Assertion):验证在代码中做出的一些假设
        - helps detect logic bugs
        - Documents code 



## 背包、队列和栈

- 背包(Bag)
    - 收集元素
    - 遍历元素
    - 不支持删除元素
- 队列(Queue)
    - 先进先出(FIFO)：enqueue,dequeue
- 栈(Stack)
    - 后进先出(LIFO)：push,pop
    - 应用
        - 邮件
        - 双栈算术表达式求值
            - 将操作数压入操作数栈
            - 将运算符压入运算符栈
            - 忽略左括号
            - 遇到右括号时，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈
    - 实现
        - 可变大小的数组
            - push：没有多余空间，数组长度加倍
            - pop：栈小于数组的1/4，数组长度减半
    - 对象游离
        - 避免对象游离：只需将被弹出的数组元素的值设为null
    
    

### Java语言特性

- 可迭代的集合类型
  - foreach语句可以遍历集合的元素
  - 集合数据类型必须实现方法iterator(), 并返回一个Iterator对象
    - Iterator类必须包含两个方法：hasNext（返回布尔值），next（返回集合中的泛型元素）
  - 集合数据类型的类声明加入 implements Iterable<Item>
- 自动装箱
  - 自动将一个原始数据类型（int）转换为一个封装类型（Integer）
  - 反之则为自动拆箱
- 泛型
  - 可以存储任意类型的数据
  - 类名后的<Item>将Item定义为一个类型参数，是一个象征性的占位符，表示的是用例将会使用的某种具体的数据类型



### 链表

- 递归的数据结构，或者为空，或者是指向一个结点(node)的引用
  - 该结点含有一个泛型的元素和一个指向另一条链表的引用
- 可以实现队列、栈
- 优点：插入和删除元素更方便
- 链表的操作
- 双向链表
- 跳舞链



## 算法分析

- 时间复杂度，空间复杂度
- 科学方法
    - 观察、假设模型、预测、验证
- 数学模型
    - 执行每条语句的频率
- 增长数量级
    - 常数,N,lgN,NlgN,N^2,2^2
- 下界
- 算法要能处理对输入的依赖
    - 对最坏情况下的性能的保证
- 内存
    - 原始数据类型
        - boolean(1),byte(1),char(2),int(4),float(4),long(8),double(8)
    - 对象
        - 对象本身的开销：16字节
        - 内存的使用都会被填充为8字节
        - 对象的引用：8字节



## 连通图

- 应用
- quick-find
    - 每个触点id代表连通分量id
    - find():访问一次
    - union():需要遍历数组
- quick-union
    - 每个触点id代表同一个分量中父节点的id 
        - 指向自己，代表是根节点
- 加权quick-union
    - union时将较小的树连接到较大的树上



## 参考资料

- Algorithms，Robert Sedgewick
