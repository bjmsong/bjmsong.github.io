---
layout:     post
title:      推荐系统三十六式之
subtitle:   服务化、存储选型及API设计
date:       2020-04-20
author:     bjmsong
header-img: img/Recommendation System/th.jpg
catalog: true
tags:
    - 推荐系统
---

### 服务化是最后一步
- 一个推荐系统的在线服务，和任何别的在线服务相比，也没有什么本质区别，只是仍然还有一些特殊性
- 提供一个在线服务，需要两个关键元素：**数据库和API**



### 存储

- 专指近线或者在线部分所用的数据库，并不包括离线分析时所涉及的业务数据库或者日志数据库
- 离线阶段得到的结果，存进数据库，供近线阶段更新，最终在在线阶段直接使用
- 离线阶段会产生哪些数据。按照用途来分，归纳起来一共就有三类  
    - 特征: 特征数据会是最多的，所谓用户画像，物品画像，这些都是特征数据，更新并不频繁
        - 特征数据有两种，一种是稀疏的，一种是稠密的，稀疏的特征常见就是文本类特征，用户标签之类的，稠密的特征则是各种隐因子模型的产出参数
            - **对于稠密特征向量，例如各种隐因子向量，Embedding 向量，可以考虑文件存储，采用内存映射的方式，会更加高效地读取和使用**
        - 特征数据又常常要以两种形态存在：一种是正排，一种是倒排
            - 正排就是以用户 ID 或者物品 ID 作为主键查询，倒排则是以特征作为主键查询
            - **正排需要用列式数据库存储，倒排索引需要用 KV 数据库存储。前者最典型的就是 HBase 和 Cassandra，后者就是 Redis 或 Memcached**
    - 模型:尤其是机器学习模型，这类数据的特点是它们大都是键值对，更新比较频繁
        - 机器学习模型
          - 模型训练阶段，如果是超大规模的参数数量，业界一般采用分布式参数服务器
          - 对于达到超大规模参数的场景在中小公司不常见，可以不用牛刀。而是采用更加灵活的`PMML`文件作为模型的存储方式
        - 非机器学习模型
          - 有一个非常典型的是相似度矩阵，物品相似度，用户相似度，在离线阶段通过用户行为协同矩阵计算得到的。相似度矩阵之所算作模型，因为，它是用来对用户或者物品历史评分加权的，这些历史评分就是特征，所以相似度应该看做模型数据
    - 结果:就是一些推荐方法在离线阶段批量计算出推荐结果后，供最后融合时召回使用。任何一个数据都可以直接做推荐结果，如协同过滤结果
        - 这类数据通常是 ID 类，召回方式是用户 ID 和策略算法名称。这种列表类的数据一般也是采用高效的 KV 数据库存储，如 Redis



#### 列式数据库

- 所谓列式数据库，是和行式数据库相对应的
- 列式数据库有个`列族`的概念，可以对应于关系型数据库中的表，还有一个`键空间`的概念，对应于关系型数据库中的数据库
- **适合批量写入和批量查询,因此常常在推荐系统中有广泛应用**
- `Cassandra`，`HBase`: Cassandra 是一个去中心化的分布式数据库，而 HBase 则是一个有 Master 节点的分布式存储
- Cassandra 在数据库的 CAP 理论中可以平滑权衡，而 HBase 则是强一致性，并且 Cassandra 读写性能优于 HBase，因此 Cassandra 更适合推荐系统，毕竟推荐系统不是业务逻辑导向的，对强一致性要求不那么强烈



#### 键值对内存数据库

- `Redis`
- Redis 你可以简单理解成是一个网络版的 HashMap，但是它存储的值类型比较丰富，有字符串、列表、有序列表、集合、二进制位
- Redis 的数据放在了内存中，所以都是闪电般的速度来读取
- 应用场景
    - 消息队列
    - 优先队列
    - 模型参数
- Redis 被人诟病的就是不太高可用，对此已经有一些集群方案，有官方的和非官方的，可以试着加强下 Redis 的高可用



#### 非数据库

- 虚拟内存映射，称为 MMAP，这可以看成是一个简陋版的数据库，其原理就是把磁盘上的文件映射到内存中，以解决数据太大不能读入内存，但又想随机读取的矛盾需求
    - 比如你训练的词嵌入向量，或者隐因子模型，当特别大时，可以二进制存在文件中，然后采用虚拟内存映射方式读取
- PMML：专门用于保存数据挖掘和部分机器学习模型参数及决策函数的。当模型参数还不足以称之为海量时，PMML 是一个很好的部署方法，可以让线上服务在做预测时并不依赖离线时的编程语言，以 PMML 协议保存离线训练结果就好



### API

- 推荐系统作为一个服务，应该以良好的接口和上游服务之间交互，因此要设计良好的API
- API 有两大类，一类数据录入，另一类是推荐服务。数据录入 API，可以用于数据采集的埋点，或者其他数据录入
<ul> 
<li markdown="1">
![]({{site.baseurl}}/img/Recommendation System/36/数据录入api.png) 
</li> 
</ul> 

- 推荐服务的 API 按照推荐场景来设计



|            | 接口       | 输入                                                         | 输出                                                         |
| ---------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 猜你喜欢   | /Recommend | * UserID – 个性化推荐的前提 <br/>* PageID – 推荐的页面 ID，关系到一些业务策略<br/> * FromPage – 从什么页面来 <br/>* PositionID – 页面中的推荐位 ID<br/> * Size – 请求的推荐数量 <br/>* Offset – 偏移量，这是用于翻页的 | * Items – 推荐列表，通常是数组形式，每一个物品除了有 ID，还有展示所需的各类元素 <br/>* Recommend_id – 唯一 ID 标识每一次调用，也叫做曝光 ID，标识每一次曝光，用于推荐后追踪推荐效果的，很重要 * Size – 本次推荐数量 <br/>* Page —— 用于翻页的 |
| 相关推荐   | /Relative  | * UserID – 个性化推荐的前提 <br/>* PageID – 推荐的页面 ID，关系到一些业务策略 <br/>* FromPage – 从什么页面来 <br/>* PositionID – 页面中的推荐位 ID * ItemID – 需要知道正在浏览哪个物品导致推荐相关物品 <br/>* Size – 请求的推荐数量<br/>* Offset – 偏移量，这是用于翻页的 | * Items – 推荐列表，通常是数组形式，每一个物品除了有 ID，还有展示所需的各类元素<br/> * Recommend_ID – 唯一 ID 标识每一次调用，也叫做曝光 ID，标识每一次曝光，用于推荐后追踪推荐效果的，很重要 <br/>* Size – 本次推荐数量 <br/>* Page —— 用于翻页的 |
| 热门排行榜 | /Relative  | * UserID – 个性化推荐的前提 <br/>* PageID – 推荐的页面 ID，关系到一些业务策略<br/> * FromPage – 从什么页面来 <br/>* PositionID – 页面中的推荐位 ID <br/>* Size – 请求的推荐数量 <br/>* Offset – 偏移量，这是用于翻页的 | * Items – 推荐列表，通常是数组形式，每一个物品除了有 ID，还有展示所需的各类元素 <br/>* Recommend_id – 唯一 ID 标识每一次调用，也叫做曝光 ID，标识每一次曝光，用于推荐后追踪推荐效果的，很重要 <br/>* Size – 本次推荐的数量<br/> * Page —— 用于翻页的 |



### 参考资料

- Personalization at Spotify using Cassandra
    - 介绍了 Spotify 在推荐系统所用到的数据存储中间件