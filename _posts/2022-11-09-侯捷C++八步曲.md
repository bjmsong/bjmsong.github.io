---
layout:     post
title:      侯捷C++八步曲
subtitle:   
date:       2022-11-09
author:     bjmsong
header-img: 
catalog: true
tags:
    - C++
---
## C++面向对象高级开发（I）
### Ojbect Based：单一class的设计
- C：没有面向对象的特性，数据是全局的，所有函数都可以处理这些数据
- C++: class/struct,把数据和函数包在一起
- class
    - without pointer members
    - with poiter members
- 头文件
    - 头文件保护符
    - 前置声明
    - 类声明
    - 类定义
- class template
    - 数据类型不写死(用T表示),使用的时候来确定数据类型
    - template<typename T>，template<class T>： 都可以 
- 函数模板
    - 调用时，编译器会自动进行实参推导（不需要指定类型）
- inline函数
    - 函数如果在class body内定义完成，就是inline函数
    - 最终由编译器决定，是不是真的inline
- 访问级别
    - public
    - private：不对外展示，比如数据
    - protected
- 构造函数
    - 创建对象的时候自动调用
    - 名称跟类名一样，没有返回类型
    - 推荐用initialization list：表示初始化，写在构造函数内部表示赋值
        - 只有构造函数有这个特性
    - 重载
        - 如果某些创建对象的场景下，不同的重载构造函数都能调用，这样的重载构造函数是不可以的
    - 一般是public
        - 如果不允许被外界创建对象，可以是private：例如单例模式

        ```C
        // Meyers Singleton
        class A {
        public:
            static A& getInstance();
            setup() {...}
        private:
            A();
            A(const A& rhs);
            ...
        }

        A& A::getInstance(){
            static A a;
            return a;
        }

        A::getInstance().setup();
        ```

    - explicit

- 常量成员函数

    ```C
    double real() const { return re; }
    ```

    - 不能修改成员变量
    - 该加const一定要加，设计函数的时候就要确定是否const

- 参数传递
    - pass by value
        - 把变量完整地复制过去，效率低
    - pass by reference：推荐使用
        - const：不修改参数
- 返回值传递
    - return by value
    - return by reference：推荐使用
        - 传递者不需要知道接收者以何种形式（by vaule or by reference）接收
        
        ```C
        complex& __doapl(complex* ths, const complex& r)
        {
            ...
            return *ths;
        }
        ```

        - const
        - 如果要返回函数内部创建的局部变量，不能使用引用，因为函数结束局部变量就销毁了
- 友元
    - 自由取得friend的private成员
    - 相同class的各个objects互为friends
- 操作符重载
    - 操作符就是一种函数，更直观
    - 可以定义为成员函数，也可以定义为非成员函数（全局函数）
    - 返回值是对象本身的类型：这样就可以连续使用操作符
- this指针
    - 所有的成员函数都（隐藏）带这个参数，不需要用户自己写
    - 指向调用的对象
- 临时对象
    - typename()
    - 生命周期只存在于当前行
- 拷贝构造
    - 如果类带指针，编译器默认提供的是浅拷贝（拷贝的是指针），需要自己写
- 拷贝赋值
    - 需要先检测是不是自我赋值
- 析构函数
    - 不带指针的类，大部分不需要析构函数
- stack，heap
    - stack
        - 存在于某作用域的一块内存空间。例如当调用函数，函数本身即会形成一个stack，用来放置它所接收的参数，以及返回地址。
        - stack object：其生命在作用域结束之际结束
        - static object：其生命在作用域结束之后仍然存在，直到整个程序结束
        - global object：其生命在整个程序结束之后才结束
    - heap
        - 操作系统提供的一块global内存空间
- new，delete
    - new：先分配memory(malloc)，再调用构造函数
    - delete: 先调用析构函数，再释放内存(free)
    - 动态分配所得的内存块
- static
    - 类内
        - 静态成员变量
            - 属于类，一个类一份，不属于对象
            - 需要在类外进行定义
        - 静态成员函数
            - 没有this指针，不能处理非静态成员变量，只能处理静态成员变量 
            - 可以通过object调用，也可以通过class name调用
- cout
    - 继承自ostream
    - 对<<进行操作符重载：适用于各种基本类型
- namespace
    - 用处：名字不会重名

### Object Oriented：多个class的设计
- 类与类之间的关系
    - 组合
    - 继承
    - 委托
- Composition：组合，表示has-a
    - A类包含一个B类的对象
    - 适配器(Adapter)模式：拿已有的类进行组合，实现新的接口
    - 构造：先调用Component的default构造函数，再调用自己的构造函数
        - 编译器默认按这个顺序调用构造函数，也可以自己实现，指定构造函数
    - 析构：先调用自己的析构函数，再调用Component的析构函数
- 委托：Delegation，Composition by reference
    - A类包含一个指向B类的指针
    - A类负责提供对外的接口（不变），B类负责具体实现（可以切换）
    - 可以实现pointer to implementation(pimpl)
        - Handle,body
- 继承: Inheritance, 表示is-a
    - public、private、protected 
    - 父类被子类继承
        - 变量
        - 函数：子类可以调用父类的函数
    - 构造
        - 子类的构造函数先调用父类的构造函数，再执行自己的构造函数
    - 析构
        - 父类的析构函数必须是virtual
        - 子类的析构函数先执行自己的析构函数，再调用父类的析构函数
    - 父类的函数
        - non-virtual：不希望子类重新定义（override）这个函数
        - 虚函数(virtual): 已有定义，子类可以重新定义
        - 纯虚函数：没有定义，子类一定要重新定义
    - template method：23个设计模式之一
        - 父类函数里面，包含virtual函数，由子类来实现
            - Applicaiton Framework - Application
    - 多态
- 观察者模式
    - Delegation + Inheritance
- Composite模式 
- Prototype模式

## C++面向对象高级开发（II）: 对象模型
- conversion function：转换函数
     - 定义（隐式）转换的规则
- one-argument(一个实参) 构造函数(ctor)
    - non-explicit：可以把符合实参类型的变量隐式转换为对象
    - explicit：不可以隐式转换，必须通过创建对象来调用构造函数
- pointer-like-class: 智能指针
    
    ```C
    template<class T>
    class shared_ptr
    {
    public:
        shared_ptr(T* p) : px(p) {}
        T& operator*() const { return *px; }
        T& operator->() const { return px; }
    private:
        T* px;
    };

    struct Foo
    {
        ...
        void method(void) {...}
    }

    shared_ptr<Foo> sp(new Foo);
    Foo f(*sp);
    sp->method();
    ```

- pointer-like-class: 迭代器
- function-like-class：仿函数
    - 重载"()"操作符 
- namespace
- member template 成员模板
    - 可以用在构造函数中，用来实现up-cast
- (full) specialization：模板特化
    - 特化是泛化的反义词
    - 针对特定的类型有特定的实现
- partial specialization：模板偏特化
    - 个数的偏：有多个模板参数，绑定其中部分模板参数
    - 范围的偏
- template template parameter
    - 模板嵌套模板 
- C++标准库
- variadic template：数量不定的模板参数
- auto
- range-base for loop
- reference：引用

## 标准库--体系结构与内核分析
- The C++ Standard Library
https://www.mica.edu.vn/perso/Vu-Hai/EE3490/Ref/The%20C++Standard%20Library%20-%202nd%20Edition.pdf
- 主要基于模板编程，而非面向对象
### STL标准库与泛型编程
- 泛型编程（Generic Programming，GP）：使用template为主要工具来编写程序
- C++ Standard Library（C++标准库）
    - 编译器自带的，以头文件形式呈现
    - 头文件扩展名不带.h
    - C头文件
        - 新式：不带.h，建议使用
        - 旧式：带.h,仍然可用
    - 新式的头文件都封装在namespace std
    - 推荐把标准库所有的容器、算法都实践一遍
- STL（Standard Template Library，标准模板库）
    - 标准库的前身&主要构成
    - 泛型编程最成功的作品
    - 分为六大组件
        - 容器（Containers）：每个容器都有对应的头文件
        - 分配器(Allocators)：支持容器
        - 算法(Algorithms)：都是function template
        - 迭代器(Iterators)：泛化的指针，算法和容器之间的桥梁
        - 适配器(Adapters)：转换
        - 仿函数(Functors)
- 参考手册
    - https://cplusplus.com/
    - https://en.cppreference.com/w/
    - https://gcc.gnu.org/
- Sequence Container
    - Array: fixed number of elements
    - Vector: 可以自动扩容
    - Deque：双向队列，两端都可以自动扩容
    - List： 双向链表
    - Forward-List：单向链表
- Associative Container
    - set
        - multiset：元素可以重复
    - map：key-value
        - multimap：key可以重复
    - unordered vs ordered
        - unordered: HashTable实现
            - seperate chaining
        - ordered：红黑树实现

## C++设计模式


## 资料
- 视频
    - youtube
    - 2015年录制
- 课件，代码
    - https://github.com/ZachL1/Bilibili-plus

## 其它
- https://www.zhihu.com/question/440479149
- https://mp.weixin.qq.com/s/nzFv_5TzLyhJOPCo_GGh1g
- https://github.com/tangtangcoding/C-C-
