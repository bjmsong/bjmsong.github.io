---
layout:     post
title:      C++工程构建
subtitle:   
date:       2022-10-01
author:     bjmsong
header-img: img/build/cmake.png
catalog: true
tags:
    - C++
---


## 构建系统（Makefile）

### 为什么需要构建系统

文件越来越多时，一个个调用g++编译链接会变得很麻烦。于是自动化编译应运而生，所谓自动化编译，一旦写好，只需要一个`make`命令，整个工程完全自动编译，极大的提高了软件开发的效率。

`make`是解释`makefile`中指令的命令工具，`makefile`定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作。

- 常用命令
  - 执行`makefile`：`make`
  - 删除执行文件和所有的中间目标文件：`make clean`
  - 能够自动**并行**地进行编译，加快编译速度：`make -j`


- 缺点
  - make 在 Unix 类系统上是通用的，但在 Windows 则不然
  - 需要准确地指明每个项目之间的依赖关系，有头文件时特别头疼
  - make 的语法非常简单，不像 shell 或 python 可以做很多判断等
  - 不同的编译器有不同的 flag 规则，为 g++ 准备的参数可能对 MSVC 不适用



### 语法规则

```
target ...: prerequisites ...
    command
    ...
    ...
```

- 显式规则
    - prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行
    - target
        - 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）
        - 必须
    - prerequisites(前置条件)
        - 生成该target所依赖的文件和/或target
        - “目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，"目标"就需要重新构建
        - 可选，但是和命令之间必须存在一个
    - command(命令)
        - 该target要执行的命令（任意的shell命令）
        - 表示如何更新目标文件
        - 必须要以 Tab 键开始
        - 可选
- 隐晦规则：简化makefile文件
    - 自动推导：只要make看到一个 .o 文件，它就会自动的把 (同文件名的) .c 文件加在依赖关系中
- 变量定义
- 文件指示
    1. 在一个Makefile中引用另一个Makefile，就像C语言中的include一样
    2. 指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样
    3. 定义一个多行的命令
- 注释
    - 只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符



## **构建系统的构建系统**（CMake）

- 优点
  - 跨平台：只需要写一份 **CMakeLists.txt**，他就能够在调用时**生成**当前系统所支持的构建系统。
  - 可以自动检测源文件和头文件之间的依赖关系，导出到Makefile里
  - 具有相对高级的语法，**内置的函数**能够处理 configure，install 等常见需求
  - 可以自动检测当前的编译器，需要添加哪些 flag。比如 OpenMP，只需要在
    CMakeLists.txt 中指明 target_link_libraries(a.out OpenMP::OpenMP_CXX) 即可
  - 开源, 免费



### 语法规则(Traditional CMake)

```cmake
cmake_minimum_required(VERSION 3.16)
project(test)

# 编译参数设置
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -fopenmp -march=native")

# 添加子模块：子模块里也有CMakeLists.txt，可以生成库，也可以生成可执行文件
add_subdirectory(demos)

# 生成可执行文件
add_executable(test source1.cpp, source2.cpp)

# 生成静态库 libtest.a
add_library(test STATIC source1.cpp source2.cpp)  
# 生成动态库 libtest.so
add_library(test SHARED source1.cpp source2.cpp)  

# 定义头文件搜索路径: 引用它的可执行文件CMake会自动添加这个路径：
target_include_directories(hellolib PUBLIC .)
# 也可以指定头文件搜索路径
target_include_directories(test PUBLIC libtest) 
# 添加头文件搜索目录（不推荐使用）
include_directories(${OpenCV_INCLUDE_DIRS})   

# 配置项
# 例如：本项目的开发者请使用set(DEVELOPMENT ON)或者在cmake中添加-DDEVELOPMENT=ON将选项打开
option(DEVELOPMENT ON)
```



### 引入第三方库

- 纯头文件库

  - 只需要把它们的 include 目录或头文件下载下来，然后 target_include_directories(spdlog/include)即可。

- 作为子模块引入

  <ul> 
  <li markdown="1">
  把项目（以fmt为例）的源码放到工程的根目录
  ![]({{site.baseurl}}/img/build/1.png) 
  </li> 
  </ul> 

- 引用系统中预安装的第三方库

  ```cmake
  # 链接库
  find_package(OpenCV REQUIRED)
  # 添加库文件的搜索路径
  target_link_libraries(test PUBLIC ${OpenCV_LIBS})
  ```

  - 现代 CMake 认为一个**包** (package) 可以提供多个**库**，又称**组件** (components)，比如 TBB 这个包，就包含了 tbb, tbbmalloc, tbbmalloc_proxy 这三个组件。因此为避免冲突，每个包都享有一个独立的名字空间，以 ::  分割。

  <ul> 
  <li markdown="1">
  ![]({{site.baseurl}}/img/build/2.png) 
  </li> 
  </ul> 



### 命令行调用

```shell
cmake -B build    # 读取当前目录的 CMakeLists.txt，并在 build 文件夹下生成 build/Makefile
make -C build     # 让 make 读取 build/Makefile，并开始构建 a.out

cmake -Bbuild -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_CXX_STANDARD=17    # 指定编译器，C++版本
```



### Modern CMake

CMake is "modern" since version 3.0(~2014年) 



## `Bazel`

Google开发的，易读性更强，但是生态不如`CMake`

[官方教程](https://bazel.build/docs/bazel-and-cpp)

[Concepts](https://bazel.build/concepts/build-ref)

- build file
    - cc_binary(): 生成可执行文件，库文件
    - cc_library(): 生成(供内部使用的)库文件
- https://stackoverflow.com/questions/51689092/playing-with-bazel-c-tutorials-build-does-not-create-use-shared-libraries

  

## 第三方库的安装

- 方法1：直接下载源码，手动构建
    - `CMake`
      
        - https://blog.csdn.net/zhangyk11/article/details/123715194
        ```shell
        mkdir build
        cd build
        cmake ..
        make -j8
        make install
        ```
        - 可以指定库的路径
    
- 方法2：使用包管理工具(例如`apt-get`，`yum`)安装

- **方法3：vcpkg，类似于python的pip**
  
    - `vcpkg install packagename`
    - CMake构建的时候指定vcpkg工具链：`-DCMAKE_TOOLCHAIN_FILE=`
    
- **方法4：conan**






