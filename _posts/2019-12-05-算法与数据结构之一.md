---
layout:     post
title:      算法与数据结构之一
subtitle:   基础
date:       2019-12-05
author:     bjmsong
header-img: img/Algo/algorithms.jpg
catalog: true
tags:
    - 算法
---
>本文首先将讲解用来实现、分析和比较算法的基本原则和方法。包括Java编程模型、数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析（union-find）



## Java编程模型

- **程序是对算法精确、优雅和完全的描述**
- 优先使用大多数现代编程语言所共有的语法
- **基础编程模型：描述和实现算法所用到的语言特性、软件库和操作系统**



### Java程序的基本结构

- **一段Java程序（类）要么是一个静态方法（函数）库，要么是定义了一个数据类型。**
- 基本语法
    - 原始数据类型：整数、浮点数、布尔值
    - 语句：声明、赋值、条件、循环、调用、返回
    - 数组
    - 静态方法：即函数，静态方法可以封装并重用代码，使我们可以用独立的模块开发程序
    - 字符串
    - 标准输入/输出
    - **数据抽象：封装和重用代码，使我们可以定义非原始数据类型，支持面向对象编程**



### Java基本语法

- 执行Java程序：先编译(javac)，再运行(java)

- **强类型语言**
  
    - 在使用变量之前，需要声明变量的名称和类型
        - 函数参数及返回值都要指定类型
    - 优点：开发阶段可以避免更多bug，运行效率更高
    
- **重载：同样的运算符对不同类型会执行不同的操作**

- **可见修饰符**

    - public
    - private
    - protected

- **复制数组**

    - 声明、创建并初始化一个新数组，然后将原数组元素逐个复制到新数组
    - 如果将一个数组赋予另一个变量（别名），两个变量会指向同一个数组

- **静态方法**
  
    - 修饰符： static
    - 参数、返回值、副作用（例如打印了一个值）
    - **方法的性质**
        - **方法的参数按值传递**：
          - 方法处理的是参数的值，而非参数本身。因此在静态方法中改变参数变量的值对调用者没有影响
          - 数组参数将会是原参数的别名，数组内容会改变
        - 方法名可以被重载
        - 方法只能返回一个值，但可以包含多个返回语句
        - 方法可以产生副作用：返回值可以是void
    - 模块化编程的优点
        - 每个模块代码大小适中
        - 可以共享和重用代码
        - 很容易用改进的实现替换老的实现
        - 可以为解决编程问题建立合适的抽象模型
        - 缩小调试范围


- **静态方法库**（如Math）
    - 定义在一个Java类中的一组静态方法
    - 存放类的文件名和类名相同
    - 包含一个main方法

- **单元测试**
    - 每个静态方法库都包含一个main()函数来测试库中的所有方法
    - 编成一个测试用例来对所有代码进行全面的测试
        - 用例：指代调用另一个库中的方法的程序

- 递归
    - 调用自己
    - 代码更简洁、优雅
    - **递归总有一个最简单的情况**
    - **递归调用总是尝试去解决一个规模更小的问题**
    - **递归调用的父问题和尝试解决的子问题之间不应该有交集**

- API（应用程序编程接口）
    - 是调用和实现之间的契约，详细说明了每个方法的作用
    - **将调用和实现分离：除了API中给出的信息，调用者不需要知道实现的其他细节**
    - **应该将自己编写的每一个程序都当做一个日后可以重用的库**
        - 编写用例，在实现中将计算过程分解成可控的部分
        - 明确静态方法库和与之对应的API
        - 实现API和一个能够对方法进行独立测试的main()函数
    
- 字符串
    - 拼接:+
    - 类型转换:parseInt,toString
    - 自动转换
    - 命令行参数:
      - 程序能够接受从命令行传来的信息
      -  用法：java 库名 字符串,字符串会作为参数传递
    - 字符串的操作
    
- 输入输出
    - **程序从标准输入流中获得输入，写入到标准输出流中**
    
    - 重定向:> <
    
    - 管道:将一个程序的输出重定向为另一个程序的输入
    
        

### 二分查找

- 算法：输入有序数组，每次跟中间值比较，如果没有找到，则将数组分成两半

- 时间复杂度：lg(N)

- 应用：白名单过滤

  

## 数据抽象（面向对象编程）

- **数据类型：一组值和一组对这些值的操作的集合**
- 抽象数据类型（ADT）：能够对使用者隐藏数据表示
- 任意数据类型都能通过在API中包含特定的方法从Java的内在机制中获益
    - 如Java所有数据类型都会继承toString()方法来返回用String表示的该类型的值
- 使用抽象数据类型
    - 抽象数据类型源代码在同一个目录
    - 或者在标准Java库中
    - 或者可以import
    - 或者在classpath中



### 对象：承载数据类型的值的实体

- 特性
    - 状态：数据类型中的值
    - 标识：在内存中的位置
    - 行为：对数据类型的操作
- 创建对象（new）
    - 分配内存空间
    - 调用构造函数初始化对象的值
    - **返回该对象的一个引用**
        - 声明原始数据类型，返回的是值本身
- **赋值语句**
    - **别名：不会创建新的对象，而只是创建另一个指向某个已经存在的对象的引用**
        - 所以改变赋值后的对象，也会改变原对象
        - 如果是原始数据类型，赋值是复制值，而不是引用
        - 别名是bug的常见原因
- 对象作为参数
    - 会改变原对象的值
- 对象作为返回值
    - 这样实际上就可以返回多个值
- 数组也是对象，所以数组的赋值机制跟对象是一致的，所有非原始数据类型都是对象



### 抽象数据类型的实现

- 类名跟文件名相同
- 实例变量
  - 定义数据类型的值
  - 每个实例变量对应着无数个值（每个实例对象都会有一个）
- 构造函数
  - 初始化实例变量
  - 名称和类名相同
  - 没有返回值，不需要指定返回值的类型（void也不需要）
  - 重载：可以有多个
- 实例方法
  - 不需要static关键字
  - 公共的：在API中说明
  - 私有的：用于辅助计算，用例无法使用
  - 某些实例方法的存在是为了尊重Java的习惯--继承的方法
- 静态方法
  - 单元测试用例：main
- 作用域
  - 参数变量：整个方法
  - 局部变量：当前代码段中它的定义之后的所有语句
  - 实例变量：整个类，如果跟局部变量冲突，可以使用this前缀来区分
- **实现步骤**
  - 定义API
  - 用一个Java类实现API的定义
  - 实现多个测试用例来验证前两步做的设计决定



### 实例方法 vs 静态方法

- 实例方法 
    - 不需要static关键字
    - 对象名.方法名
    - 作用：访问或者改变对象的值
- 静态方法
    - static关键字
    - 类名.方法名
    - 作用：计算返回值
    - 访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制



### 数据类型的设计

- 封装（Encapsulation）
    - 使用数据类型的实现封装数据，以简化实现、隔离用例开发
    - 将程序分解为能够独立开发和调试的小型模块，将修改代码的影响限制在局部区域
    - 保持模块之间的独立性（减少耦合）
    - 静态库可以更新，API保持不变
- **设计API**
    - 最重要，最有挑战
    - 设计API付出的时间都能从调试和代码复用所节省的时间中获得回报
    - 与抽象数据类型相关联的值，一系列构造函数和实例方法的目的和副作用的自然语言描述
    - 包含用例代码
    - 只为用例提供它们所需要的（敏捷开发也倡导先写用例，再写实现）
- **接口继承**
    - 继承机制：子类型
    - 接口
        - 一组公共的方法
        - 为两个本来没有关系的类建立联系
        - 这两个类都必须实现这些方法
        - 定义接口：interface
        - 引用接口：implements
    - **调用接口中的方法可以操作实现该接口的任意类型的对象**
    - 接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性
- 实现继承
    - 继承机制：子类
    - 继承父类的所有实例方法和实例变量
    - 可以重写父类的方法
    - Object:所有类的父类
    - extends
- 封装类型
    - 每个原始数据类型都有一个对应的封装类型
      - 如：int -> Integer
    - 在需要的时候Java会自动将原始数据类型转换为封装类型
      - 如int值需要和String连接时，它的类型会被转换为Integer并触发toString()方法
- 等价性（equals）
    - 自反性
    - 对称性
    - 传递性
- Java自动内存管理
    - 垃圾回收:将孤儿对象的内存释放，即回收所有无法被访问的对象的内存
- **不可变性**
    - 不可变数据类型：该类型的对象中的值在创建之后就无法再被改变，如String，Date
    - final修饰符
    - 优点：预防意外修改，也使程序的调试更加简单
    - 缺点：
        - 需要为每个值创建一个新对象
        - 只能用来保证原始数据类型的实例变量的不可变性，而无法用于引用类型的变量
- **契约式设计**
    - 异常(Exception)：用于处理不受我们控制的不可预见的错误
        - 最佳实践：一旦出错就立刻抛出异常，使定位出错位置更容易
    - 断言(Assertion):验证在代码中做出的一些假设
        - helps detect logic bugs
        - Documents code 



## 背包、队列和栈

- 背包(Bag)
    - 收集元素
    - 遍历元素
    - 不支持删除元素
- 队列(Queue)
  
    - 先进先出(FIFO)：enqueue,dequeue
- 栈(Stack)
    - 后进先出(LIFO)：push,pop
    - 应用
        - 邮件
        - 双栈算术表达式求值
            - 将操作数压入操作数栈
            - 将运算符压入运算符栈
            - 忽略左括号
            - 遇到右括号时，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈
    - 实现
        - 可变大小的数组
            - push：没有多余空间，数组长度加倍
            - pop：栈小于数组的1/4，数组长度减半
    - 对象游离
        - 避免对象游离：只需将被弹出的数组元素的值设为null
    
    

### Java语言特性

- 可迭代的集合类型
  - foreach语句可以遍历集合的元素
  - 集合数据类型必须实现方法iterator(), 并返回一个Iterator对象
    - Iterator类必须包含两个方法：hasNext（返回布尔值），next（返回集合中的泛型元素）
  - 集合数据类型的类声明加入 implements Iterable<Item>
- 自动装箱
  - 自动将一个原始数据类型（int）转换为一个封装类型（Integer）
  - 反之则为自动拆箱
- 泛型
  - 可以存储任意类型的数据
  - 类名后的<Item>将Item定义为一个类型参数，是一个象征性的占位符，表示的是用例将会使用的某种具体的数据类型



### 链表

- 递归的数据结构，或者为空，或者是指向一个结点(node)的引用
  - 该结点含有一个泛型的元素和一个指向另一条链表的引用
- 链表表示的是一列元素
- 快：插入和删除元素
- 慢：查找数据
- 双向链表：删除任意元素的效率比单向链表高
- 实现队列、栈、背包
- 舞蹈链

|                  | 优点                           | 缺点                           |
| ---------------- | ------------------------------ | ------------------------------ |
| 数组（顺序存储） | 通过索引可以直接访问任意元素   | 在初始化时就需要知道元素的数量 |
| 链表（链式存储） | 使用的空间大小和元素数量成正比 | 需要通过引用访问任意元素       |



## 算法分析

#### 科学方法

- 细致地观察世界，通常还需要精确的测量
- 根据观察结果提出假设模型
- 根据模型预测未来的事件
- 继续观察并核实预测的准确性
- 如此反复确认，直到预测和观察一致

关键原则：所设计的实验必须是可重现的，这样他人也可以自己验证假设的真实性。

所有的假设也必须是可证伪的



### 时间复杂度

我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率

- 时间复杂度

    假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)

- 大”O“记法

    对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n)<=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似

- 时间复杂度的几条基本计算规则

    - 基本操作，即只有常数项，认为其时间复杂度为O(1)
    - 顺序结构，时间复杂度按加法进行计算
    - 循环结构，时间复杂度按乘法进行计算
    - 分支结构，时间复杂度取最大值
    - 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
    - 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度



### 空间复杂度

- 只需要分析声明语句

- 内存
  
    - 原始数据类型
      
        - boolean(1字节),byte(1),char(2),int(4),float(4),long(8),double(8)
    - 对象
        - 对象本身的开销：16字节
        
        - 实例变量使用的内存
        
        - 对于64位机器，内存的使用都会被填充为8字节的倍数
        
        - 如：一个Integer对象会使用24字节（16字节的对象开销、4字节的int、4字节填充）
        
          

## union-find算法（动态连通性问题）

- 应用
    - 网络内计算机是否连接
    - 判断变量名是否等价
    - 数学集合
- quick-find
    - 每个触点id代表连通分量id
    - find():访问一次
    - union():需要遍历数组
- quick-union
    - 每个触点id代表同一个分量中父节点的id 
        - 指向自己，代表是根节点
- 加权quick-union
    - union时将较小的树连接到较大的树上
    - **可以解决大型实际问题**



## 参考资料

- Algorithms，Robert Sedgewick
- https://www.ranxiaolang.com/static/python_algorithm/chapter1/index.html
