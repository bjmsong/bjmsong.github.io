---
layout:     post
title:      推荐系统三十六式之
subtitle:   常见架构
date:       2020-04-18
author:     bjmsong
header-img: img/Recommendation System/th.jpg
catalog: true
tags:
    - 推荐系统
---


### 信息流架构

#### 整体框架

- 如果要搜索 feed 相关的技术文章，应该用`Activity Stream`作为关键词去搜，而不应该只用`feed`搜索

<ul> 
<li markdown="1">
![]({{site.baseurl}}/img/Recommendation System/36/信息流架构.png) 
</li> 
</ul> 

- 模块
    - 日志收集：是所有排序训练的数据来源，要收集的最核心数据就是用户在信息流上产生的行为，用于机器学习更新排序模型
    - 内容发布：用推或者拉的模式把信息流的内容从源头发布到受众端
    - 机器学习：从收集的用户行为日志中训练模型，然后为每一个用户即将收到的信息流内容提供打分服务
    - 信息流服务：为信息流的展示前端提供Rest API
    - 监控：系统的运维标配，保证系统的安全和稳定等



#### 数据模型

- **User**
    - 存储：MySQL
- **Activity：内容**
    - 用于表达 Activity 的元素有相应的规范，叫作 `Atom`，你可以参考它并结合产品需求，定义出自己的信息流数据模型来
    - 根据 Atom 规范的定义，一条 Activity 包含的元素有：Time、Actor、Verb、Object、Target、Title、Summary
    - 存储：MySQL、Redis、Cassandra
- **Connection：关系**
    - 存储：mysql



#### 动态发布

- Fan-out：动态内容出现在受众的信息流中这个过程
- **“拉”模式**（Fan-out-on-load）：信息流是在用户登录或者刷新后实时产生的
    1. 获取用户所有连接的终点（如好友、关注对象、兴趣标签）
    2. 获取这些连接终点（关注对象）产生的新内容（Activity）
    3. 按照某个指标排序后输出

<ul> 
<li markdown="1">
![]({{site.baseurl}}/img/Recommendation System/36/拉模式.png) 
</li> 
</ul> 

- 拉模式就是当用户访问时，信息流服务才会去相应的发布源拉取内容到自己的 feed 区来，这是一个阻塞同步的过程。“拉”模式的好处也显而易见，主要有下面两种
    - 实现简单直接：一行 SQL 语句就搞定了
    - 实时：内容产生了，受众只要刷新就看得见
- 拉模式不足
    - 随着连接数的增加，这个操作的复杂度指数级增加
    - 内存中要保留每个人产生的内容
    - 服务很难做到高可用
- **“推”模式**（Fan-out-on-write）：当一个 Actor 产生了一条 Activity 后，不管受众在不在线，刷没刷新，都会立即将这条内容推送给相应的用户（即和这个 Actor 建立了连接的人），系统为每一个用户单独开辟一个信息流存储区域，用于接收推送的内容。如此一来，当用户登录后，系统只需要读取他自己的信息流即可

<ul> 
<li markdown="1">
![]({{site.baseurl}}/img/Recommendation System/36/推模式.png) 
</li> 
</ul> 

- 推模式的优点：在用户访问自己的信息流时，几乎没有任何复杂的查询操作，所以服务可用性较高
- 推模式的缺点：
  - 大量的写操作：每一个粉丝都要写一次
  - 大量的冗余存储：每一条内容都要存储 N 份（受众数量）
  - 非实时：一条内容产生后，有一定的延迟才会到达受众信息流中
  - 无法解决新用户的信息流产生问题

- 既然两者各有优劣，那么实际上就应该将两者结合起来，一种简单的结合方案是全局的：

    - 对于活跃度高的用户，使用推模式，每次他们刷新时不用等待太久，而且内容页相对多一些
    - 对于活跃度没有那么高的用户，使用拉模式，当他们登录时才拉取最新的内容
    - 对于热门的内容生产者，缓存其最新的 N 条内容，用于不同场景下的拉取

- 还有一种结合方案是分用户的，这是 Etsy 的设计方案：

    - 如果受众用户与内容产生用户之间的亲密度高，则优先推送，因为更可能被这个受众所感兴趣
    - 如果受众用户与内容产生用户之间的亲密度低，则推迟推送或者不推送
    - 也不是完全遵循亲密度顺序，而是采用与之相关的概率

- **在中小型的社交网络上，采用纯推模式就够用了，结合的方案可以等业务发展到一定规模后再考虑**

- 信息流推送

    - Celery等框架

    

#### 信息流排序

- 通常做成RPC服务，供调用



#### 数据管道

- Netflix推荐架构
    - 工程实现才是推荐系统的骨架
    - 好的推荐系统架构
        - 实时响应需求
        - 及时、准确、全面记录用户反馈
        - 可以优雅降级
        - 快速试验多种策略
    - 架构
        - 离线层：不用实时数据，不提供实时服务
        - 近线层：使用实时数据，不保证实时服务
        - 在线层：使用实时数据，要保证实时服务
- 推荐架构和搜索、广告的关系



### 关键模块

- 数据采集
    - 数据模型
        - 把数据归类
        - 用户属性、物品属性、事件（曝光、浏览、购买）、关系数据
    - 数据在哪
        - 基本信息
        - 埋点
            - SDK埋点
            - 可视化埋点
            - 无埋点：尽可能多的收集所有数据
            - 神策、友盟。。。
    - 元素有哪些
    - 如何收集
    - 质量检验
- 实时推荐
    - 实时数据
        - 实时消息队列
        - kafka
    - 流计算
        - storm
        - flink
- 实验平台
    - ABtest
- 服务化、存储选型及API设计
    - 存储
        - 离线阶段得到的结果，存进数据库，供近线阶段更新，最终在在线阶段直接使用
        - 数据类型
            - 特征
                - 稀疏 稠密
                - 正排：用户ID或者物品ID作为主键  -- 列式数据库
                  倒排：特征作为主键 -- KV数据库
            - 模型
            - 结果
        - 不同存储方式
            - 列式数据库
                - 适合批量写入和批量查询
                - Cassandra，HBase
            - 键值数据库
                - Redis
                - 数据放在内存中
                - 场景
                    - 消息队列
                    - 优先队列
                    - 模型参数
            - 非数据库
                - 虚拟内存映射
                - PMML
                    - 适合模型参数比较少
                    - 线上服务预测时不依赖离线时的编程语言
    - API
        - 数据录入
        - 推荐服务



### 效果保证

- 测试方法
    - 业务规则扫描
        - 将业务规则翻译成单元测试
    - 离线模拟测试
        - topK：AUC
    - 在线对比测试
        - ABTest
    - 用户访谈
- 常见指标
    - 系统有多好
        - 深度
            - 评分准确度：RMSE
            - 排序：AUC
                - 而不是用采用搜索引擎排序指标(MAP、MRR、NDCG),因为推荐结果非常个人化
            - 分类准确率
                - topK：准确率，召回率
        - 广度
             - 覆盖率
             - 失效率
             - 新颖性
             - 更新率
    - 还能好多久
        - 个性化
        - 基尼系数
        - 多样性
- 推荐系统的攻防



### 开源工具
慎重选择分布式，先把单机发挥到极致，除非过亿用户以上
- 内容分析
    - 主题模型
        - LightLDA
        - gensim
        - plda
    - 词嵌入
        - gensim
        - tensorflow-word2vec
        - Fasttext
    - 文本分类
        - Fasttext
        - liblinear
- 协同过滤和矩阵分解
协同过滤：通过计算矩阵的行相似和列相似得到推荐结果
矩阵分解：得到用户和物品的隐因子向量，是低维稠密向量，进一步以用户的低维稠密向量在物品的向量中搜索得到近邻结果
    - KNN相似度计算
    - SVD矩阵分解
    - SVD++矩阵分解
    - ALS矩阵分解
    - BPR矩阵分解
    - 低维稠密向量近邻搜索
  simHash
  Faiss nmslib
- 模型融合
线性模型训练部分离线批量进行，线上预测部分比较简单，可以用开源的接口，也可以自己实现
    - LightGBM
    - XGBOOST
    - tensorflow-wide&deep
    - libFFM
    - vowpal_wabbit 
- 其他
    - bandit：自己实现
    - 深度学习：tensorflow
    - 存储、接口
- 完整推荐系统:算法+存储+接口
    - PredictionIO
    - recommendationRaccon
    - easyrec
    - hapiger