---
layout:     post
title:      python基础教程
subtitle:   
date:       2020-03-19
author:     bjmsong
header-img: img/language/python.jpg
catalog: true
tags:
    - python
---



### 基础

- 基本特点

  - 动态类型语言：运行的时候才去检查数据类型，需要写更多的单元测试 
    - 对应静态类型语言，运行之前编译时要检查数据的类型：C++， Java，Scala
  -  解释性语言  对应编译性语言 C++
  - 面向对象 ：对应 面向过程 C
  - 介于脚本语言和系统语言之间 ：对应 系统语言 C++ ，C， Java

- 变量名称应该要有实际意义，让人一眼可以知道含义

- 整除： //

- 脚本直接运行：`#!+` 解释脚本的程序的绝对路径，如: #!/usr/bin/env python

- 原始字符串: 以r开头，对于反斜线不会特殊对待

- Unicode字符串：以u开头，python3中，所有字符串都是Unicode字符串

- 获取用户输入

  ```
  raw_input("what's your name?")
  ```

  



####  深拷贝、浅拷贝

- 赋值：只是复制了新对象的引用，不会开辟新的内存空间
    - a=b
    - 原始列表与被赋值的列表会同时变动
- 浅拷贝：创建新对象，其内容是原对象的引用
    - 切片操作:lst[:]
    
    - 工厂函数:list(lst)
    
    - copy.copy
    
    - 原始数据与浅拷贝的对象改动不会互相影响
    
    - 但是，原始数据改变，子对象会改变
    
      ```
      import copy
      alias = [1,2,3,['a','b'],5]
      c = copy,copy(alias)
      alias.append(5)
      print(alias)
      print(c)
      
      alias[3].append(5)
      print(alias)
      print(c)
      ```
- 深拷贝:创建一个全新的对象，跟原来的对象没有关系
  
    - `copy.deepcopy`
- https://www.cnblogs.com/xueli/p/4952063.html
- https://www.cnblogs.com/huangbiquan/p/7795152.html



### 列表和元组

- 6种内建序列：列表、元组、字符串、Unicode字符串、buffer对象、xrange对象
- 列表可以修改，元组则不能
- 通用序列操作：索引、分片、相加、乘法、成员资格、长度、最小值、最大值
- 列表：
    - []
    - list
    - 赋值、删除
    - append、count、extend、index、insert、pop、remove、reverse、sort
- 元组
    - ()
    - tuple
    - 作用
        - 元组可以在映射中当做键，列表不行
        - 元组可以作为很多内建函数和方法的返回值
- 集合(set)
    - 可变
    - 并集、子集、交集



### 使用字符串

- 字符串不可变
- 字符串格式化
- 字符串方法：find、join、lower、replace、split、strip、translate



### 字典

- 键：数字、字符串、元组
- {},dict()
- 字典的格式化字符串
- 字典方法：clear、copy、fromkeys、get、has_key、items/iteritems、keys/iterkeys、pop、setdefault、update



### 条件、循环和其他语句

- 赋值魔法
    - 序列解包
      
        ```
        x,y=y,x
        ```
        
    - 增量赋值
    
    - 链式赋值
    
- 缩进
  
    - 推荐只用空格
    
- if elif else

- 断言：与其让程序在晚些时候崩溃，不如在错误条件出现时直接崩溃

- 循环
    - while
    - for
    - 迭代工具
        - range
        - zip：并行迭代
        - enumerate：按索引迭代
        - reversed、sorted：翻转和排序迭代
    - 跳出循环
        - break：结束循环
        - continue：跳过剩余的循环体，但是不结束循环
        - 循环中的else语句：在没有调用break时执行
    - **列表推导式**
        - 利用其他列表创建新列表
            - [x*x for x in range(10) if x%3 == 0]
    
- pass:占位符

- del：会移除一个对象的引用，也会移除那个名字本身

- exec：执行一个字符串
  
    ```
    exec("print 'Hello world'")
    ```
    
- eval：计算python表达式



### 抽象

- 函数
    - 文档字符串：在函数的开头写下字符串，它就会作为函数的一部分进行存储
        - 访问：function.__doc____
        - help(function):得到关于函数的信息
- 函数参数
    - 形参：def语句函数名后面的变量
    - 实参：调用函数的时候提供的值
    - **在函数内为参数赋予新值不会改变任何外部变量的值**
        - **但是，可变数据结构(如列表)作参数时会发生改变**：当两个变量同时引用一个列表时，它们的确是同时引用一个列表
    - 位置参数：调用函数时根据函数定义的参数位置来传递参数
    - 关键字参数：顺序没有关系，可以提供默认值
        - **位置参数必须在关键字参数前面**
    - 收集参数
        - *params:用户可以提供任意数量的参数
        - **params：收集任意数量的关键字参数
- 作用域
    - 局部变量&全局变量
- 递归
    - 包含两部分
        - 当函数直接返回值时有基本实例（最小可能性问题）
        - 递归实例，包括一个或者多个问题最小部分的递归调用
        - 阶乘，二分查找。。。
- 函数式编程
    - map、filter、reduce



### 更加抽象

- **多态：可以对不同类的对象使用同样的操作**
    - 就算不知道对象是什么类型，还是能对它进行操作，而它也会根据对象类型的不同而表现出不同的行为
- **封装：对外部世界隐藏对象的工作细节**
- **继承：以通用的类为基础建立专门的类对象**
- 类
    - self：自己作为第一个参数传入函数中
    - 特性
    - 方法
        - 私有方法：名字前面加双下划线
        - 想让其他对象不要访问：单下划线
            - 前面有下划线的方法都不会被 import * 导入
    - 指定超类：将其他类名写在class语句的圆括号内
    - 检查继承：issubclass
    - 多重继承：应该尽量避免使用
- **面向对象**
    - 将属于一类的对象放在一起
    - 避免使用多重继承
    - 不要让对象过于亲密，方法应该只关系自己实例的特性
    - 方法要尽量简单：代码控制在一页之内，30s内被读完
    - **面向对象草图设计**
        - 写下问题的描述
        - 名词--类
        - 动词--方法
        - 形容词--特性
        - 考虑对象之间的关系（如继承）
        - 写下使用实例，考虑每个使用实例，保证模型包括所有需要的东西



### 异常

- 知道某段代码可能会导致某种异常，而又不希望程序以堆栈跟踪的形式终止，那么就需要添加try/catch或者try/finally语句进行处理
- 引发异常：raise
- 内建异常类
- 自定义异常类
- 捕捉异常
    - try/catch
    - 捕捉多个异常
    - 全捕捉
    - else语句：如果try块中没有引发异常，else子句就会被执行
- finally



### 魔法方法、属性和迭代器

- 魔法方法：名字前后加下双划线

- 构造方法：__init__
    - 对象被创建后，会立即调用构造方法
    - 重写构造方法：需要调用超类的构造方法
        - super   
    
- 成员访问
    - 创建行为类似于序列或者映射的对象
        - 实现魔术方法
            - __len__(self):返回集合中所含项目的数量
              -  `__len__`
            - __getitem__(self,key):返回与所给键对应的值
            - __setitem__(self,key,value)
            - __delitem__(self,key)
        - 继承
            - 子类化列表，字典和字符串
    
- **装饰器：增强函数的功能**

- 属性
  
    - 属性：通过访问器定义的特性
    - property函数
        - @property
        - 调用起来跟普通的特性一样
        - 在新式类中应该使用property函数而不是访问器方法
            - python3之后，所有的类都派生自内置类型object
    - 静态方法和类成员方法
        - 静态方法：@staticmethod
            - 没有self参数，可以被类本身直接调用
        - 类成员方法：@classmethod
            - cls参数，可以直接用类的具体对象调用
    
- 迭代器
    - 迭代是Python最强大的功能之一，是访问集合元素的一种方式
    
    - 有两个基本方法：`iter`,`next`
    
        ```
        lst = [1,2,3,4]
        it = iter(lst)
        print(next(it))
        print(next(it))
        
        for x in it:
        	print(x, end = " ")
        ```
    
    - 把一个类作为一个迭代器使用需要在类中实现两个方法：`__iter__()`,`__next()__`
      
    - StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在  __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
      
        ```
        class MyNumbers:
          def __iter__(self):
            self.a = 1
            return self
         
          def __next__(self):
            if self.a <= 20:
              x = self.a
              self.a += 1
              return x
            else:
              raise StopIteration
         
        myclass = MyNumbers()
        myiter = iter(myclass)
         
        for x in myiter:
        	print(x)
        ```
        
    - 更通用，更简单，更优雅
      
        - 列表会占用太多内存
        
    - 可迭代：实现了__iter__方法的对象
    
    - 显式地将迭代器转化为列表：`list`
    
- 生成器(generator)
    - **任何包含yield语句的函数成为生成器**
    
    - **跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器**
    
    - 被调用时，在函数体中的代码不会被执行，而会返回一个迭代器。每次请求一个值，就会执行生成器的代码，直到遇到yield或者return
    
        ```
        import sys
         
        def fibonacci(n): # 生成器函数 - 斐波那契
            a, b, counter = 0, 1, 0
            while True:
                if (counter > n): 
                    return
                yield a
                a, b = b, a + b
                counter += 1
        f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
         
        while True:
            try:
                print (next(f), end=" ")
            except StopIteration:
                sys.exit()
        ```
    
    - 可以写出优雅的代码
    
    - 生成器推导式
    
        ```
        (i*2 for i in range(10))
        ```
    
        

### 模块

- 模块
    - sys.path：解释器寻找模块的路径
        - site-packages目录是最佳选择
        - 永久：修改PYTHONPATH 
            - .bashrc文件
    - 模块中自带main函数作为测试
    - 包
        - 必须包含一个__init__文件
        - 模块的组合
- 模块探究
    - dir函数：查看模块包含的内容
    - __all__变量
    - help获取帮助
    - 文档:__doc__
    - 源代码:__file__
- 标准库
    - sys
    - os
    - heapq
        - 优先队列：能够以任意顺序增加对象，并且能够在任何时间找到最小的元素
    - collections
    - time、datetime
    - random
    - re



### 文件和流

- 打开文件
    ```
    with open(filepath) as somefile:   # 模式：r，w，a。。
    	do_something(somefile)
    ```
    
- 读和写
  
    - f.read,f.write
    - f.readlines,f.writelines
    
- 管式输出
    - `|` : 将一根命令的标准输出和下一个命令的标准输入连在一起
      
        ```
        cat somefile.txt | python somescript.py | sort
        ```
    
    



### 图形用户界面



### 网络编程

- socket
    - 套接字：两个端点的程序之间的信息通道
- 爬虫 
    - urlib，urlib2
        - 缺点
            - 正则表达式难以理解，不可维护
            - 网页结构的微小改变都可能导致程序失败
            - 部分HTML特性无法处理
    - Beautiful Soup
        - 解析和检查不规范的HTML 



### 测试

- **先测试，后编码**
    - **精确的需求说明：描述程序必须满足的需求**
    - **根据需求编写单元测试**
        - 帮助程序员在开发时不偏离需求
        - 可以避免在实施修改时引入错误
    - **测试的4个步骤**
        - 指出需要的特性，然后为其编写一个测试
        - 编写特性的骨架代码，确保程序可以运行，并且测试会失败
            - 在试图让测试成功前，先要看到它失败
        - 为特性的骨架编写哑代码，满足测试要求就行，不要准确地实现功能
        - 重构代码，保证测试成功
- 测试工具
    - doctest：检查代码是否符合文档字符串的要求
    - unittest
        - 通用测试框架
        - pycharm封装了这个模块
        - 运行所有名字以test开头的方法
- 源代码检查
    - 寻找代码中普通错误或者问题
    - PyCheck
    - PyLint
- 性能分析
    - profile：打印出各个函数和方法调用的次数，以及每个函数花费的时间
    - timeit：查看执行时间



### 好玩的编程

- python扩展
- 程序打包
- 原型设计
- 配置
    - 全局变量
    - 配置文件 
        - method1：为配置创建单独的模块
        - method2：使用标准库模块ConfigParser
- 日志
    - logging

- [PEP8](https://www.python.org/dev/peps/pep-0008/)



