---
layout:     post
title:      C++工程构建
subtitle:   
date:       2022-10-26
author:     bjmsong
header-img: 
catalog: true
tags:
    - C++
---
## 编译
- https://cplusplus.com/doc/tutorial/introduction/
- 编译器
    - GCC, G++，MinGW（GCC的windows版本）
    https://blog.csdn.net/weixin_38145317/article/details/105225505
    - llvm+Clang
https://blog.csdn.net/gatieme/article/details/42914393
- 编译：源文件(.c/.cpp)->可执行目标文件
    - 预处理：根据以#开头的命令，修改原始的C程序
    - 编译(compile)：将文本文件翻译成汇编语言程序
        - 编译器只检测程序语法和函数、变量是否被声明
    - 汇编：翻译成机器语言指令，打包成.o文件
    - 链接(link)：把大量的.o文件合并成执行文件
        - 链接器会在所有的.o文件中找寻函数的实现
- 不同系统(windows,mac,linux)编译的项目不能兼容

## makefile
- https://seisman.github.io/how-to-write-makefile/index.html
- 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作
- 自动化编译：一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率
- make是一个命令工具，是一个解释makefile中指令的命令工具
    - 执行makefile：make
    - 删除执行文件和所有的中间目标文件：make clean
- makefile文件

```
target ...: prerequisites ...
    command
    ...
    ...
```

- 显式规则
    - prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行
    - target
        - 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）
        - 必须
    - prerequisites(前置条件)
        - 生成该target所依赖的文件和/或target
        - “目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，"目标"就需要重新构建
        - 可选，但是和命令之间必须存在一个
    - command(命令)
        - 该target要执行的命令（任意的shell命令）
        - 表示如何更新目标文件
        - 必须要以 Tab 键开始
        - 可选
- 隐晦规则：简化makefile文件
    - 自动推导：只要make看到一个 .o 文件，它就会自动的把 (同文件名的) .c 文件加在依赖关系中
- 变量定义
- 文件指示
    1. 在一个Makefile中引用另一个Makefile，就像C语言中的include一样
    2. 指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样
    3. 定义一个多行的命令
- 注释
    - 只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符

## CMake
- 《Cmake 实践.pdf》
https://github.com/fishCoder/CMakePractice/blob/master/cmake%E5%AE%9E%E8%B7%B5.pdf
- 开源、免费、跨平台
- 本质是定义各个目标之间的关联
- 边用边学
- 也是一种编程语言，可以用来实现基本的程序逻辑
    - 例如可以根据工程的配置来选择性编译部分源代码
- 安装依赖
    - CMake
        - 方法一：yum install
        - 方法二：https://cloud.tencent.com/developer/article/1668873

            ```
            wget -c https://github.com/Kitware/CMake/releases/download/v3.17.0-rc3/cmake-3.17.0-rc3.tar.gz
            tar zxvf cmake-3.17.0-rc3.tar.gz
            cd cmake-3.17.0-rc3
            ./bootstrap
            gmake
            gmake install

            ln -s /usr/local/bin/cmake /usr/bin/cmake
            cmake --version
            ```

    - 编译器 
    - C++第三方库
        - 方法1：直接下载库的源文件，手动构建并指定CMake库的路径
        - 方法2：使用包管理工具(如apt-get)安装
        - 方法3(推荐)：vcpkg，类似于python的pip
            - vcpkg install packagename
            - CMake构建的时候指定vcpkg工具链： -DCMAKE_TOOLCHAIN_FILE=
- linux环境
https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click&vd_source=7798c62f92ce545f56fd00d4daf55e26
    - 编译
    - 构建
    - 使用cmake进行安装（二进制、动态库、静态库、文件、脚本、目录）： cmake install
    - 构建静态库和动态库
        - 静态库和动态库的区别
            - 静态库的扩展名一般为“.a”或“.lib”; 动态库的扩展名一般为“.so”或“.dll”
            - 静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行
            - 动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行
    - 安装头文件和共享库
- https://github.com/BrightXiaoHan/CMakeTutorial
- https://zhuanlan.zhihu.com/p/52874931
- windos环境
https://www.bilibili.com/video/BV1rR4y1E7n9?is_story_h5=false&p=1&share_from=ugc&share_medium=android&share_plat=android&share_session_id=e3804bb0-3008-4a55-9dad-4e3d0e50e5f0&share_source=WEIXIN&share_tag=s_i&timestamp=1660873694&unique_k=5ExOdKk
    - 配置：根据CMakeLists.txt, 自动生成目标平台下的原生工程文件(windows下的vs工程，linux下的makefile...)
        - vscode: cmake configure 
        - 命令行：cmake -S . -B build
    - 构建
        - vscode: cmake build, F7
        - 命令行：cmake --build build

    ``` 
    # 工程名字，可执行文件的名字
    project(EXAMPLE)

    # 在计算机中寻找第三方库
    find_package(glm REQUIRED)

    # 构建可执行文件
    add_executable(${CMAKE_PROJECT_NAME} ${SRC_FILES})

    # 链接
    target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE glm)
    ```

- https://www.bilibili.com/video/BV1o34y1675i/?spm_id_from=333.337.search-card.all.click&vd_source=7798c62f92ce545f56fd00d4daf55e26 
- 
https://www.hahack.com/codes/cmake/
https://www.zhihu.com/question/58949190
- 查看: man命令
- 官网: https://cmake.org/
- 《professional cmake》

## Bazel
单个工具完成不同语言在不同环境下的构建
https://blog.csdn.net/weixin_44970102/article/details/123577855
