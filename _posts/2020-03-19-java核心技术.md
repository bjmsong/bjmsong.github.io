---
layout:     post
title:      Java核心技术
subtitle:   
date:       2020-03-19
author:     bjmsong
header-img: img/language/java.jpg
catalog: true
tags:
    - Java
---



### Java特性
- 简单性

    - Java语法是C++语法的一个“纯净”版本

- 面向对象

    - 将重点放在数据（即对象）和对象的接口上
    - Java和C++的主要不同点在于多继承，在Java中，取而代之的是简单的接口概念，以及Java的元类模型

- 网络技能
  
    - 通过url打开和访问网络上的对象，十分容易
    
- 健壮性
  
    - Java编译器能够检测很多其他语言在运行时才能发现的问题
    
- 安全性

- 体系结构中立
  
    - 编译器生成一个体系结构中立的目标文件格式
    
- 可移植性

- 解释型

- 高性能

- 多线程

- 动态性

  

### Java程序设计环境

- 安装Java开发工具箱

  - 下载JDK（Java Development Kit）
    - Java运行时环境（JRE）：包含虚拟机但不包含编译器，不是开发者需要的环境
  - 设置执行路径
  - 安装库源文件和文档

- 开发环境

  - 集成开发环境：IntelliJ IDEA，Eclipse

    - 先编译:将`Welcome.java`编译成`Welcome.class`，并发送到虚拟机

      ```shell
      javac Welcome.java
      ```

    - 再执行：虚拟机执行编译器放在class文件中的字节码

      ```
      java Welcome
      ```

  - 命令行

  

### Java基本程序设计结构
#### 基本特点

- 大小写敏感

- 访问修饰符：public、private、protected

- 类名大写字母开头，驼峰命名

- 源代码的文件名必须与公共类的名字相同，并用`.java`作为扩展名

- 用`{}`分割程序的各个部分：块，复合语句

    - 不能在嵌套的两个块中声明同名的变量

- 每个Java应用程序都必须有一个`main`方法

    ```java
    public class ClassName
    {
    	public static void main(String[] args)
    	{
    	  program statements
    	}
    }
    ```

- 注释：

    - `//`
    - `/* */`
    - `/** */`:可以自动生成文档

#### 数据类型

- 整型：int，short，long，byte
- 浮点型：float，double
- 字符类型：char
- 布尔类型：boolean

#### 变量

- 必须声明类型且初始化
- 常量：关键字final，不能更改 
    - 类常量：static final

#### 运算符

- 算术运算符

- 自增、自减运算符

- 关系运算符： `== , !=`

- 逻辑运算符： `&&,||,!`
  
    - 三元操作符：`condition?expression1:expression2`
    
      ```java
      x<y?x:y
      ```
    
- 位运算符: `&、|、^(异或)、~、>>、<<`

- 数学函数：Math类

- 数值类型之间的转换

    <ul> 
    <li markdown="1"> 
    ![]({{site.baseurl}}/img/language/java数值类型转换.png) 
    </li> 
    </ul> 

    - 实心箭头表示无信息丢失的转换

    - 虚箭头表示可能有精度损失的转换

    - 当不同数据类型的数据进行二元操作时（如`+`），先要将两个操作数转换为同一种类型，然后再进行计算

    - 强制类型转换

      ```
      double x = 9.997;
      int nx = (int) x ;               // 截断小数部分得到整数
      int nx2 = (int) Math.round(x) ;  // 四舍五入得到整数
      ```

- 枚举类型：包含有限个命名的值
    
    ```java
    enum Size {SMALL,MEDIUM,LARGE,EXTRA_LARGE}
    ```
    
    Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null值

#### 字符串：Unicode字符序列

- 子串：substring

- 拼接：+

    - 每次拼接会构建一个新的String对象

- 字符串不可变，但是可以修改字符串变量，让它引用另外一个字符串

- 检查是否相等

    ```java
    string1.equals(string2)
    ```

    - 不能用`==` ,这个运算符只能确定两个字符串是否放在同一个位置

- 空串，null串

    - 检查一个字符串是否为空

        ```java
        if(str.length()==0)
        // 或者
        if(str.equals(""))
        ```

    - 检查一个字符串是否为null，表示目前没有任何对象与该变量关联

        ```java
        if(str == null)
        ```

    - 检查一个字符串既不是null，也不是空串

        ```java
        if(str != null && str.length() != 0 )
        ```

- 字符串API

    ```java
    int compareTo(String other)
    boolean endsWith(Object suffix)
    boolean startsWith(Object prefix)
    boolean equals(Object other)
    int indexOf(String str)
    int length()
    String replace(CharSequence oldString,CharSequence newString)
    String substring(int beginIndx)
    String toLowerCase()
    String trim()
    ........
    ```

- 构建字符串

    - 由较短的字符串构建字符串，用字符串连接的方式效率比较低，因为每次连接字符串，都会构建一个新的String对象。使用`StringBuilder`类就可以避免这个问题的发生。

        ```java
        StringBuilder builder = new StringBuilder();
        builder.append(ch);
        builder.append(str);
        String completedString = builder.toStrig();
        ```

#### 输入输出

- 读取输入
    ```java
    import java.util.*  // Scanner类定义在java.util包中，不在基本java.lang包中
    Scanner in = new Scanner(System.in); // 构造Scanner对象，并与标准输入流System.in关联
        
    System.out.print("what is your name?");
    String name = in.nextline();
    String firstName = in.next();
    
    System.out.print("how old are you?");
    int age = in.nextInt();
    ```
    
- 输出
  ```java
  System.out.print(x);
  System.out.printf("%8.2f",x);   // 格式化输出
  ```
  
- 文件输入与输出
    - 读取
    
      ```java
      Scanner in = new Scanner(Paths.get(filepath))  // 用一个File对象构造一个Scanner对象
      ```
    
    - 写入
    
      ```java
      PrintWriter out = new PrintWriter(filepath)
      ```

#### 控制流程

- 条件语句：`if(condition) statement1 else statement2`
- 循环语句
    - `while(condition) statement`
    - for
- 多重选择：`switch`
- 中断控制流程：`break`,`continue`

#### 大数值

-  `java.math  BigInteger BigDecimal`

#### 数组

- 声明并初始化：`int[] a = new int[100]`

- **数组一旦创建，就不能改变大小，尽管可以改变每一个数组元组** 

    - `array list`可以改变大小

- 遍历集合中的元素
    `for(variable:collection) statement`
    
       - **collection 必须是一个数组或者一个实现了Iterable接口的类对象** 
    
       - 更简单的方式打印数组中的所有值
    
         ```
         System.out.println(Arrays.toString(a))
         ```
    
- 数组拷贝
    ```java
    int[] a = b; // a和b将引用同一个数组
    int[] a = Arrays.copyOf(b,b.length); // 拷贝值 
    ```
    
- 命令行参数
    
    ```java
    public static void main(String[] args)  // main方法将接收一个字符串数组
    ```
    
- 数组排序
    
    ```java
    int[] a = new int[10000];
    Arrays.sort(a); // 快排
    ```
    
- 多维数组    



### 对象与类

#### 面向对象(OOP) 设计概述

- 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分
- 面向对象把定义数据结构放在第一位，然后再考虑操作数据的算法
- 面向过程的开发方式：适用于规模较小的问题
- 面向对象的开发方式：适用于规模较大的问题
- 类
    - 由类构造对象的过程称为创建类的实例
    - 所有类都源自于一个超类 `Object`
- 对象
    - 行为：对对象施加哪些方法
    - 状态：对对象施加那些方法时，对象如何响应
    - 标识：如何辨别具有相同行为和状态得到不同对象
- 识别类
    - **先设计类，再添加方法**
    - **识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。**
- 类之间的关系
    - **依赖**：`uses-a`，一个类的方法操纵另一个类的对象
        - **应该尽可能将相互依赖的类减至最少 -- 类之间的耦合度最小**
    - **聚合:**`has-a`，类A的对象包含类B的对象
    - **继承**:`is-a`
    - UML绘制类图：工具`Plantuml`

#### 使用预定义类

- 并不是所有类都具有面向对象特征，如Math类，只封装了功能，不需要隐藏数据

- 流程；构造对象，并指定其初始状态，对对象应用方法

- 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象

    - 在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用

        ```java
        // 构造了一个Date类型的对象，并且它的值是新创建对象的引用 ,这个引用存储在变量deadline中
        Date deadline = new Date();  
        ```

- Date类：表示时间点

  - Date类的`getDay`,`getMonth`,`getYear`等方法，并不推荐使用

- GregorianCalendar类/Calendar类：表示日历表示法

  ```java
  // 已知年、月、日，创建一个包含这个时间值的Date对象
  GregorianCalendar calendar = new GregorianCalendar(year,month,day);
  Date hireDay = calendar.getTime();
  
  // 获得Date对象的年、月、日信息
  GregorianCalendar calendar = new GregorianCalendar();
  calendar.setTIme(hireDay);
  int year = calendar.get(Calendar.YEAR);
  ```

- 更改器方法与访问器方法

  - 更改器方法（mutator method）：对实例域做出修改的方法
    - 方法名前加上前缀`set`
  - 访问器方法（accessor method）：仅访问实例域而不进行修改的方法
    - 方法名前加上前缀`get`

#### 用户自定义类

- 主力类：没有`main`方法，却有自己的实例域和实例方法。

- 创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有`main`方法

- 

- 封装

    - 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。
        - 私有的数据域
        - 公有的域访问器方法
            - 不要返回引用可变对象，会破坏封装性，需要先克隆(clone)
        - 公有的域更改器方法
            - 可以执行错误检查
    - 优点
        1、良好的封装能够减少耦合。
        2、类内部的结构可以自由修改。
        3、可以对成员进行更精确的控制。
        4、隐藏信息，实现细节。

    - 继承
    - 多态
        - 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
        - 父类指向子类的对象
    - 类之间的关系
        - 继承：is-a
        - 依赖：uses-a
        - 聚合：has-a
    - 使用构造器构造新实例
        - 构造器的名字与类名相同
        - 只执行一次，伴随着new操作符的执行被调用
        - 每个类可以有一个以上的构造器
        - 构造器没有返回值
        - 不要在构造器中定义与实例域重名的局部变量
    - 预定义类：Date,GregorianCalendar

- 自定义类
    - 完整的程序：包含若干个类，只有一个类有main方法
    - 一个源文件中，只能有一个公有类，但可以有任意数目的非公有类
    - 访问限制
        - public：任何类都可以访问
        - private：只有类内部可以访问
        - protected：继承的类也可以访问
    - 强烈建议将实例域标记为private
    - 隐式参数：方法前的对象，关键字this
    - 显式参数：方法名后面括号中的数值
    - 私有方法
    - final实例域：不能修改，应用于基本类型域、不可变类的域（如String）

- 静态域与静态方法
    - 静态域
        - 定义为static
        - 属于类，不属于任何一个对象
        - 每个类只有一个这样的域，与之相对的，每个对象对于所有的实例域都有一份拷贝
    - 静态常量
        - static final
        - 如：Math.PI，System.out
    - 静态方法
        - 一种不能向对象实施操作的方法
        - 没有隐式的参数
        - 不能在静态方法中访问实例域，但是可以访问自身类中的静态域
        - 使用场景：
            - 一个方法不需要访问对象状态，其所需要的参数都通过显示参数提供(如Math.pow(x,a))
            - 一个方法只需要访问类的静态域
    - 工厂方法
        - NumberFormat使用工厂方法产生不同风格的格式对象
    - main方法
        - 静态方法
        - 启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需的对象
        - 每个类可以有一个main方法，可以用来进行单元测试

- 方法参数
    - 按值调用
        - 方法得到的是参数值的拷贝，不能修改参数变量
    - 按引用调用
        - 方法得到的是变量地址，可以修改参数值
    - java总是采用按值调用
        - 方法得到的是参数值的一个拷贝，不能修改传递给它的参数变量的内容
            - 当参数是基本数据类型（数字，布尔值）：不能修改
            - 当参数是对象引用：可以改变变量的状态，因为对象的拷贝及对象同时引用同一个对象

- 对象构造
    - 重载
        - 多个方法有相同的名字、不同的参数
        - 编译器根据参数类型来挑选用哪个方法
        - 不能有两个名字相同、参数类型也相同却返回不同类型值的方法
        - 如果在构造器中没有显式地给域赋予初值(不建议这样)，那么就会自动赋为默认值：数值为0，布尔值为false，对象引用为null
            - 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器
        - 参数名要有意义，可阅读
        - 构造器的第一个语句如this(),将调用同一个类的另一个构造器
            - 应用于继承

- 包
    - 包(package)将类组织起来
    - 确保类名的唯一性，包名：公司的因特网域名逆序(如com.ctrip)
    - 包作用域
        - public：任意的类都能访问
        - private：只能在同一个类中访问
        - 没有指定：同一个包中的所有方法都可以访问 
    - 要将类放入包中，就必须将包的名字放在源文件的开头(package com.ctrip)，同时将包中的文件放到与完整的包名匹配的子目录中
        - 以包为单位构建IDE工程

- 类路径
    - 类文件也可以存储在jar包中
    - 为了使类能够被多个程序共享，需要：
        - 把类放到一个目录中，按照包名的结构
        - 将jar文件放到一个目录中
        - 设置类路径(class path)：所有包含类文件的路径的集合
            - java -classpath
            - export CLASSPATH

- 文档注释
    - javadoc：可以由源文件生成一个HTML文档
        - 抽取注释:javadoc -d DocDirectory nameOfPackage
    - 以界定符/**开始注释
    - 方法注释:@para @return @throws
    - 通用注释：@autho @version @deprecated @see

- 类设计技巧
    - 一定要保证数据私有
    - 一定要对数据显示初始化
    - 不要在类中使用过多的基本类型
        - 应该用其他的类代替多个相关的基本类型的使用
    - 不是所有的域都需要独立的域访问器和域更改器
    - 将职责过多的类进行分解
        - 如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解
    - 类名和方法名要能够体现它们的职责
        - 良好的类名：名词(Order),前面有形容词修饰的名词(RushOrder),动名词修饰名词(BillingAddress)
        - 良好的方法名：访问器以get开头,更改器以set开头



### 继承

- 类、超类和子类
    - extends表示继承
    - 超类、基类、父类
    - 子类、派生类
    - 子类比超类拥有的功能更加丰富
        - 通用的功能放在超类中，具有特殊用途的方法放在子类中
        - 子类可以增加域、增加方法或者覆盖超类的方法，然而绝对不能删除继承的任何域和方法
    - 子类访问超类的私有域，必须借助于公有的接口
    - 调用超类的方法，而不是当前类的这个方法，用super关键字
    - java不支持多继承
        - 接口可以支持
    - 多态(polymorphism)
        - 一个对象变量可以指示多种实际类型的现象
        - 置换法则：程序中出现超类对象的任何地方都可以用子类对象置换
        - 动态绑定：在运行时能够自动地选择调用哪个方法
    - 不允许扩展的类被称为final类
        - final class ...
        - final method : 子类不能覆盖
    - 强制类型转换
        - (int) x
        - (Manager) staff
    - 抽象类
        - 包含抽象方法的类
        - 关键字：abstract
        - 抽象方法：不需要具体实现，充当占位的角色，具体实现在子类中
        - 不能被实例化
    - protected
        - 受保护访问：允许被子类访问
        - 要谨慎使用，有可能会破坏封装性
- Object：所有类的超类
    - 可以使用Object类型的变量引用任何类型的对象
    - 只有基本类型不是对象
    - 方法
        - equals
        - hasCode
        - toString
- 泛型数组列表
    - ArrayList：可以自动调节数组容量
    - 泛型：<>
- 对象包装器与自动装箱
    - 基本类型转换为对象
    - 包装器(基本类型对应的类):Integer,Long,Float,Double,Short,Byte,Character,Void,Boolean
- 参数数量可变的方法
    - public double max(double...values)
        - 传入的参数会当成double[],任意个数
- 枚举类
    - public enum Size {SMALL,MEDIUM,LARGE}
        - 类，有3个实例，可以添加构造器、方法和域
    - 比较两个枚举类型的值时，不需要调用equals,使用 == 就可以了
- 反射
- 继承设计的技巧
    - 将公共操作和域放在超类
    - 不要使用受保护的域
    - 使用继承实现 is-a 关系
    - 除非所有继承的方法都有意义，否则不要使用继承
    - 在覆盖方法时，不要改变预期的行为
    - 使用多态，而非类型信息
    - 不要过多地使用反射



### 接口与内部类

- 接口
    - 描述类具有什么功能，而并不给出每个功能的具体实现
    - 一个类可以实现多个接口
    - 关键字:interface
    - 为了让类实现一个接口，需要以下步骤
        - 将类声明为实现给定的接口
            - class Employee implements Comparable
        - 对接口中的所有方法进行定义
            - public int compareTo(Object otherObject)
            {
                Employee other = (Employee) otherObject;
                return Double.compare(salary,other.salary)
            }
    - instanceof:检查一个对象是否属于某个类，也可以检查一个对象是否实现了某个特定的接口
    - 接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性
- 对象克隆
    - 深拷贝
    - 创建一个新的对象，对新对象进行修改时，不会改变原始对象的状态
- 接口与回调
- 内部类
    - 定义在一个类的内部



### 异常、断言、日志和调试

- **在Java程序运行时，常常会出现一些非正常的现象，根据其性质可分为错误和异常。一般来说，最常见的错误有程序进入死循环、内存泄漏等。这种情况下，程序运行时本身无法解决。Java错误对应的类为Error类。通常Java程序不对这类错误进行处理。**
- **异常是程序执行时遇到的可避免的程序错误，常见的有数组下标越界，算法溢出（超出数值表达范围）、除数为零、无效参数等。这种情况程序运行时本身可以解决，Java异常对应的类为Exception类。它有各种不同的子类分别对应于不同类型的异常。通常异常有两种处理方式，一种是通过catch捕获，一种是通过throws声明异常。**
- 处理错误
    - 目的
        - 向用户通告错误：更好地解释错误
        - 保存所有的工作结果
        - 允许用户以妥善的形式退出程序：捕获异常可以不终止程序，让程序从异常中恢复过来
    - 异常对象都是派生于Throwable类的一个实例
        - Exception：IO Exception(程序没问题，I/O错误之类)，Runtime Exception(程序错误)
        - Error
    - 要声明已检查异常(否则编译没法通过)
        - 未检查异常：派生于Error类或RuntimeException类的所有异常
        - 已检查异常：所有其他的异常
        - 未检查异常要不不可控制(Error),要不就应该避免发生(RuntimeException)
            - 如果出现RuntimeException，就一定是你的问题！
        - 一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器可能发生什么错误
            - 方法应该在其首部声明所有可能抛出的异常
                - 如：public FileInputStream(String name) throws FileNotFoundException
    - 抛出异常
        - **高调抛出，便于定位问题**
- 捕获异常
    - **低调捕获，从而不影响代码的正常执行，提高程序的健壮性**
    - try/catch
        - 如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，name
            - 程序将跳过try语句块的其余代码
            - 执行catch子句的代码
    - 应该捕获那些知道如何处理的异常，传递那些不知道如何处理的异常
    - finally子句
- 使用异常机制的技巧
    - 异常处理不能代替简单的测试：异常捕获很耗时
    - 不要过分的细化异常
    - 利用异常层次结构
    - 不要压制异常
    - 在检测错误时，苛刻比放任更好
    - 不要羞于传递异常
- 断言
    - 断言机制允许在测试期间向代码插入一些检查语句，当代码发布时，这些语句会被自动移走
    - assert
    - 启用断言：java -enableaeertions MyApp
    - 什么情况下使用
        - 断言失败是致命的、不可恢复的错误
        - 断言检查只用于开发和测试阶段
- 记录日志
    - 优点
        - 可以很容易地取消全部日志记录，或者仅取消某个级别的日志
        - 可以很简单地禁止日志记录的输出
        - 日志记录可以被定向到不同的处理器：控制台输出，存储到日志文件
        - 可以对记录进行过滤
        - 可以采用不同的方式格式化
        - 可以使用多个日志记录器
        - 日志系统的配置由配置文件控制，可以通过修改配置文件来修改日志系统
- 调试技巧
    - 单元测试框架：JUnit
    - 捕获System.out  ： java MyProgram > info.txt
      捕获System.error : java MyProgram 2> error.txt
      同时捕获:java MyProgram >& all.txt



### 集合







### 学习资料

- Java核心技术 卷I

- https://www.udacity.com/course/java-programming-basics--ud282
- https://www.cnblogs.com/chenssy/category/525010.html
- https://www.cnblogs.com/gaofei-1/p/6435442.html
